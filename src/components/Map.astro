---
import { geoAlbersUsa, geoPath } from 'd3-geo';
import { feature, mesh } from 'topojson-client';

export interface Props { }

// Canvas size used for projection and the SVG viewBox.
const WIDTH = 960;
const HEIGHT = 520;

// Server-side: pre-render SVG paths so the map appears without client bundling.
let statePaths = [];
let nationPath = '';
if (import.meta.env.SSR) {
  try {
    const fs = await import('fs');
    const path = await import('path');
    const topoPath = path.resolve(process.cwd(), 'public', 'topo', 'states-10m.json');
    const txt = fs.readFileSync(topoPath, 'utf-8');
    const topo = JSON.parse(txt);
    const states = feature(topo, topo.objects.states);
    const nation = mesh(topo, topo.objects.nation, (a, b) => a === b);

    const projection = geoAlbersUsa().fitSize([WIDTH, HEIGHT], states);
    const pathGen = geoPath(projection);

    statePaths = (states.features || []).map((f) => ({ d: pathGen(f), id: f.id }));
    if (nation) nationPath = pathGen(nation);
  } catch (err) {
    // If topo can't be read at build-time, leave paths empty and let client render later.
    console.error('Map SSR pre-render failed:', err);
  }
}
---
<div class="panel" data-t1-map>
  <div class="label"><strong>US Map</strong><span id="map-selected" class="badge">--</span></div>
  <!-- Simple map controls: zoom in, zoom out, reset -->
  <div class="map-controls" role="toolbar" aria-label="Map controls">
    <button id="map-zoom-in" type="button" class="map-control-btn" aria-label="Zoom in" title="Zoom in">+</button>
    <button id="map-zoom-out" type="button" class="map-control-btn" aria-label="Zoom out" title="Zoom out">-</button>
    <button id="map-reset" type="button" class="map-control-btn" aria-label="Reset view" title="Reset view">R</button>
  </div>
  <svg
    width="100%"
    height="520"
    viewBox={`0 0 ${WIDTH} ${HEIGHT}`}
    preserveAspectRatio="xMidYMid meet"
    role="img"
    aria-label="Map of the United States"
    tabindex="0"
  >
    <!-- group we will pan/zoom by manipulating the SVG viewBox from client-side -->
    <g id="mapGroup">
      {statePaths.map(p => (
        <path d={p.d} data-fips={p.id} class="state" />
      ))}
      <g data-layer="counties" aria-hidden="true"></g>
      {nationPath ? <path d={nationPath} class="nation" /> : null}
    </g>
  </svg>
</div>

<!-- Lightweight client script to attach click handlers and dispatch state events. -->
<script type="module">
  // Parse the SVG viewBox at runtime to obtain WIDTH/HEIGHT so we don't need server-side injection here.
  // This avoids template interpolation issues and keeps the script robust when executed in the browser.

  function initMapClient() {
  const root = document.querySelector('[data-t1-map]');
  if (!root) return;
  const svg = root.querySelector('svg');
  if (!svg) return;
  // breadcrumb so we know the map script actually ran
  root.setAttribute('data-js', 'ready');
  // runtime diagnostic
  try { console.log('initMapClient', { href: location.href }); } catch (e) {}

const selBadge = root.querySelector('#map-selected');
if (selBadge) selBadge.textContent = '--';

// Normalize any garbled control glyphs at runtime (defensive against encoding issues)
const _outBtn = root.querySelector('#map-zoom-out'); if (_outBtn) _outBtn.textContent='-';
const _rstBtn = root.querySelector('#map-reset');   if (_rstBtn) _rstBtn.textContent='R';

// Minimal FIPS code map so the badge shows 'CA' instead of '06'
const FIPS_TO_CODE = {
  '01':'AL','02':'AK','04':'AZ','05':'AR','06':'CA','08':'CO','09':'CT',
  '10':'DE','11':'DC','12':'FL','13':'GA','15':'HI','16':'ID','17':'IL',
  '18':'IN','19':'IA','20':'KS','21':'KY','22':'LA','23':'ME','24':'MD',
  '25':'MA','26':'MI','27':'MN','28':'MS','29':'MO','30':'MT','31':'NE',
  '32':'NV','33':'NH','34':'NJ','35':'NM','36':'NY','37':'NC','38':'ND',
  '39':'OH','40':'OK','41':'OR','42':'PA','44':'RI','45':'SC','46':'SD',
  '47':'TN','48':'TX','49':'UT','50':'VT','51':'VA','53':'WA','54':'WV',
  '55':'WI','56':'WY','72':'PR'
};
const CODE_TO_FIPS = Object.fromEntries(Object.entries(FIPS_TO_CODE).map(([f, code]) => [code, f]));
function fipsToCode(f) {
  if (!f) return null;
  const s = String(f);
  const two = s.length === 1 ? '0' + s : s;
  return FIPS_TO_CODE[two] || null;
}

// --- Selection & deep-link helpers ---
let selectedFips = null;
let selectedCountyFips = null;
let currentStateCode = null;

const countyLayer = svg.querySelector('[data-layer="counties"]');
const countyElements = new Map();
let countiesReady = false;
let localScopeActive = false;

const scopeRoot = document.querySelector('[data-component="scope-selector"]');
if (scopeRoot) {
  localScopeActive = scopeRoot.getAttribute('data-local') === '1';
}
root.setAttribute('data-local-active', localScopeActive ? '1' : '0');

function emitStateDetail(fips) {
  const detail = fips ? { fips, code: fipsToCode(fips) || null } : null;
  window.dispatchEvent(new CustomEvent('t1:state', { detail }));
}

function updateBadge(fips) {
  if (!selBadge) return;
  if (!fips) {
    selBadge.textContent = '--';
    return;
  }
  const code = fipsToCode(fips);
  selBadge.textContent = code || fips;
}

function updateHistory(fips, push) {
  try {
    const normalized = fips ? String(fips).slice(0, 2).padStart(2, '0') : null;
    const share = typeof window !== 'undefined' ? window.__T1_SHARE__ : null;
    const statePayload = normalized ? { fips: normalized } : {};
    if (share && typeof share.setModel === 'function') {
      share.setModel({ state: { fips: normalized } });
      share.scheduleURLUpdate?.({
        push: !!push,
        state: statePayload,
        delay: push ? 0 : 150,
      });
      return;
    }
    const url = new URL(location.href);
    if (normalized) {
      url.searchParams.set('fips', normalized);
    } else {
      url.searchParams.delete('fips');
    }
    if (push) {
      history.pushState(statePayload, '', url);
    } else {
      history.replaceState(statePayload, '', url);
    }
  } catch (err) {
    try { console.warn('map: permalink update failed', err); } catch (_e) {}
  }
}

let geoProjectionPromise = null;
let countiesPromise = null;
let mapSize = { width: 960, height: 520 };

function ensureGeography() {
  if (geoProjectionPromise) return geoProjectionPromise;
  geoProjectionPromise = (async () => {
    try {
      const [{ geoAlbersUsa, geoPath }, topo] = await Promise.all([
        import('d3-geo'),
        import('topojson-client')
      ]);
      const res = await fetch('/topo/states-10m.json', { cache: 'force-cache' });
      if (!res.ok) throw new Error(`states topo fetch failed: ${res.status}`);
      const topoJson = await res.json();
      const states = topo.feature(topoJson, topoJson.objects.states);
      const projection = geoAlbersUsa().fitSize([mapSize.width, mapSize.height], states);
      const path = geoPath(projection);
      return { projection, path };
    } catch (err) {
      try { console.warn('map: failed to initialise geography', err); } catch (e) {}
      return null;
    }
  })();
  return geoProjectionPromise;
}

function highlightCounty(fips) {
  if (!countyLayer) return;
  if (selectedCountyFips) {
    const prev = countyElements.get(selectedCountyFips);
    if (prev) prev.classList.remove('county--selected');
  }
  selectedCountyFips = fips || null;
  if (selectedCountyFips) {
    const next = countyElements.get(selectedCountyFips);
    if (next) next.classList.add('county--selected');
  }
}

function setCountyVisibility(stateCode) {
  if (!countyLayer) return;
  countyElements.forEach((el) => {
    if (!stateCode || el.getAttribute('data-state') === stateCode) {
      el.setAttribute('data-visible', '1');
    } else {
      el.removeAttribute('data-visible');
    }
  });
  if (selectedCountyFips) {
    const el = countyElements.get(selectedCountyFips);
    if (!el || el.getAttribute('data-state') !== stateCode) {
      highlightCounty(null);
    }
  }
}

function ensureCountyLayerLoaded() {
  if (!countyLayer) return Promise.resolve();
  if (countiesReady) return Promise.resolve();
  if (countiesPromise) return countiesPromise;
  countiesPromise = (async () => {
    const geo = await ensureGeography();
    if (!geo || !geo.path) return;
    let href = '/local/counties-sample.geojson';
    try {
      const pack = window.__T1_PACK__ || window.__t1_pack || null;
      const candidate = pack && pack.registry && pack.registry.layers && pack.registry.layers.counties;
      if (candidate && candidate.href) href = candidate.href;
    } catch {}
    try {
      const res = await fetch(href, { cache: 'reload' });
      if (!res.ok) throw new Error(`counties fetch failed: ${res.status}`);
      const data = await res.json();
      const list = (data && data.features) || [];
      const NS = 'http://www.w3.org/2000/svg';
      list.forEach((feature) => {
        const props = feature && feature.properties ? feature.properties : {};
        const fips = String(props.fips || props.GEOID || '');
        if (!fips) return;
        const state = (props.state || fipsToCode(fips.slice(0, 2)) || '').toUpperCase();
        const name = props.name || props.NAME || '';
        const d = geo.path(feature);
        if (!d) return;
        const path = document.createElementNS(NS, 'path');
        path.setAttribute('d', d);
        path.setAttribute('data-county-fips', fips);
        path.setAttribute('data-state', state);
        if (name) path.setAttribute('data-county-name', name);
        path.classList.add('county');
        countyLayer.appendChild(path);
        countyElements.set(fips, path);
      });
      countiesReady = true;
      if (selectedCountyFips) {
        highlightCounty(selectedCountyFips);
      }
    } catch (err) {
      try { console.warn('map: failed to load counties overlay', err); } catch (e) {}
    }
  })();
  return countiesPromise;
}

function syncCountyLayer() {
  if (!countyLayer) return;
  const active = localScopeActive && !!currentStateCode;
  root.setAttribute('data-local-active', active ? '1' : '0');
  if (!active) {
    countyLayer.setAttribute('aria-hidden', 'true');
    setCountyVisibility(null);
    highlightCounty(null);
    return;
  }
  countyLayer.setAttribute('aria-hidden', 'false');
  ensureCountyLayerLoaded().then(() => {
    setCountyVisibility(currentStateCode);
  });
}

function clearSelection({ emit = true, push = false } = {}) {
  const prevFips = selectedFips;
  if (prevFips) {
    const prev = svg.querySelector(`.state[data-fips=\"${prevFips}\"]`);
    if (prev) prev.classList.remove('state--selected');
  }
  selectedFips = null;
  currentStateCode = null;
  syncCountyLayer();
  highlightCounty(null);
  updateBadge(null);
  let hadParam = false;
  try {
    hadParam = new URL(location.href).searchParams.has('fips');
  } catch {}
  if (prevFips || hadParam) {
    updateHistory(null, push);
  }
  if (emit) emitStateDetail(null);
}

function selectState(fips, { emit = true, push = false } = {}) {
  if (!fips) {
    clearSelection({ emit, push });
    return;
  }

  const next = svg.querySelector(`.state[data-fips=\"${fips}\"]`);
  if (!next) {
    try { console.warn('selectState: path not found', fips); } catch (e) {}
    return;
  }

  if (selectedFips && selectedFips !== fips) {
    const prev = svg.querySelector(`.state[data-fips=\"${selectedFips}\"]`);
    if (prev) prev.classList.remove('state--selected');
  }

  selectedFips = fips;
  next.classList.add('state--selected');
  currentStateCode = fipsToCode(fips) || currentStateCode;
  syncCountyLayer();
  updateBadge(fips);

  try { console.log('selectState', { fips, code: fipsToCode(fips) || null }); } catch (e) {}
  try {
    const group = svg.querySelector('#mapGroup');
    if (group && next) group.appendChild(next);
  } catch (e) {}

  updateHistory(fips, push);

  if (emit) emitStateDetail(fips);
}

// Apply selection from URL on load (or enforce a neutral state)
(function applyInitialSelection() {
  try {
    const url = new URL(location.href);
    const f = url.searchParams.get('fips');
    if (f) {
      selectState(f, { emit: true, push: false });
      return;
    }
  } catch (err) {
    try { console.warn('map: failed to read initial fips', err); } catch (e) {}
  }
  clearSelection({ emit: true, push: false });
})();

// React to back/forward navigation
window.addEventListener('popstate', (e) => {
  const f = (e.state && e.state.fips) || (new URL(location.href)).searchParams.get('fips');
  if (f) {
    selectState(f, { emit: true, push: false });
  } else {
    clearSelection({ emit: true, push: false });
  }
});


    // --- Click handlers (per-path + delegated fallback) ---

    // Ensure state paths receive pointer events (some browsers/styles may override)
    svg.querySelectorAll('.state').forEach((p) => { try { p.style.pointerEvents = 'auto'; } catch (e) {} });

    // Single delegated click handler (robust): use elementFromPoint as a fallback
    // and emit a single selection event. This avoids duplicate listeners and
    // is resilient to overlays or small layout differences.
    svg.addEventListener('click', (ev) => {
      try {
        if (localScopeActive) {
          let countyPath = null;
          if (ev.target instanceof Element) {
            countyPath = ev.target.closest ? ev.target.closest('.county[data-visible="1"]') : null;
          }
          if (!countyPath && document.elementsFromPoint) {
            const els = document.elementsFromPoint(ev.clientX, ev.clientY);
            for (const el of els) {
              if (!(el instanceof Element)) continue;
              const c = el.closest ? el.closest('.county[data-visible="1"]') : (el.classList && el.classList.contains('county') ? el : null);
              if (c) { countyPath = c; break; }
            }
          }
          if (!countyPath && !document.elementsFromPoint && document.elementFromPoint) {
            const el = document.elementFromPoint(ev.clientX, ev.clientY);
            countyPath = el && el.closest ? el.closest('.county[data-visible="1"]') : null;
          }
          if (countyPath) {
            const countyFips = countyPath.getAttribute('data-county-fips');
            if (countyFips) {
              const stateAttr = (countyPath.getAttribute('data-state') || '').toUpperCase();
              const stateCode = stateAttr || fipsToCode(countyFips.slice(0, 2)) || null;
              const stateFips = ((stateCode && CODE_TO_FIPS[stateCode]) || countyFips.slice(0, 2) || '').padStart(2, '0');
              if (stateFips) {
                if (!selectedFips || selectedFips !== stateFips) {
                  selectState(stateFips, { emit: true, push: true });
                }
                currentStateCode = stateCode || currentStateCode;
                syncCountyLayer();
              }
              highlightCounty(countyFips);
              const detail = {
                fipsCounty: countyFips,
                countyName: countyPath.getAttribute('data-county-name') || undefined,
                state: stateCode || undefined,
                stateFips: stateFips || undefined,
                source: 'map'
              };
              window.dispatchEvent(new CustomEvent('t1:locality-changed', { detail }));
              return;
            }
          }
        }

        // Prefer the event target. If an overlay sits on top of the svg (e.g. a
        // panel that visually overlaps), use elementsFromPoint to search the
        // stack for a .state element underneath.
        let path = null;
        if (ev.target instanceof Element) path = ev.target.closest ? ev.target.closest('.state') : null;

        if (!path) {
          // Look through the element stack under the pointer to find a .state
          // even if it's not the topmost element.
          if (document.elementsFromPoint) {
            const els = document.elementsFromPoint(ev.clientX, ev.clientY);
            for (const e of els) {
              if (!(e instanceof Element)) continue;
              const p = e.closest ? e.closest('.state') : (e.classList && e.classList.contains('state') ? e : null);
              if (p) { path = p; break; }
            }
            if (path && els[0] !== path) {
              try { console.log('map:click overlay hit top element', els[0], 'found state underneath', path); } catch (e) {}
            }
          } else if (document.elementFromPoint) {
            const el = document.elementFromPoint(ev.clientX, ev.clientY);
            path = el && el.closest ? el.closest('.state') : (el && el.classList && el.classList.contains('state') ? el : null);
          }
        }

        if (!path) return;
        const f = path.getAttribute('data-fips');
        if (!f) return;
        try { console.log('map:click', { fips: f }); } catch (e) {}
        selectState(f, { emit: true, push: true });
      } catch (err) {
        try { console.warn('map click handler error', err); } catch (e) {}
      }
    });

    // Pointer events for SVG states are provided via CSS (avoid inline style mutations).

  // --- Pan & Zoom using viewBox manipulation ---
  // read initial viewBox from the svg element (format: 'x y w h')
  const vbStr = svg.getAttribute('viewBox') || '0 0 960 520';
  const vbParts = vbStr.trim().split(/\s+/).map(Number);
  const [vbX, vbY, vbW, vbH] = vbParts;
  let vb = { x: vbX || 0, y: vbY || 0, w: vbW || 960, h: vbH || 520 };
  const WIDTH = vb.w;
  const HEIGHT = vb.h;
  mapSize = { width: WIDTH, height: HEIGHT };
  const minW = WIDTH * 0.15; // max zoom-in
  const maxW = WIDTH * 1.8;  // max zoom-out

    // Debounced emitter so other components can listen to view changes without flooding.
    let _emitTimeout = null;
    function emitMapViewDebounced() {
      if (_emitTimeout) clearTimeout(_emitTimeout);
      _emitTimeout = setTimeout(() => {
        window.dispatchEvent(new CustomEvent('t1:map-view', { detail: { x: vb.x, y: vb.y, w: vb.w, h: vb.h } }));
        _emitTimeout = null;
      }, 80);
    }

    function setViewBox() {
      svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
      emitMapViewDebounced();
    }

    setViewBox();
    // Emit initial view synchronously once
    window.dispatchEvent(new CustomEvent('t1:map-view', { detail: { x: vb.x, y: vb.y, w: vb.w, h: vb.h } }));

    // Wheel to zoom (centered on pointer)
    svg.addEventListener('wheel', (evt) => {
      evt.preventDefault();
      const rect = svg.getBoundingClientRect();
      const cx = (evt.clientX - rect.left) / rect.width;
      const cy = (evt.clientY - rect.top) / rect.height;
      const px = vb.x + cx * vb.w;
      const py = vb.y + cy * vb.h;

      const zoomFactor = evt.deltaY < 0 ? 0.9 : 1.1;
      const newW = Math.max(minW, Math.min(maxW, vb.w * zoomFactor));
      const newH = (newW * HEIGHT) / WIDTH;
      const factor = newW / vb.w;

      vb.x = px - (px - vb.x) * factor;
      vb.y = py - (py - vb.y) * factor;
      vb.w = newW;
      vb.h = newH;
      clampVB();
      setViewBox();
    }, { passive: false });

    // Drag to pan (pointer events)
    let dragging = false;
    let dragStart = null;
    let vbStart = null;

    svg.addEventListener('pointerdown', (e) => {
      // Only start drag when primary button
      if (e.button !== 0) return;
      dragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      vbStart = { ...vb };
      try { svg.setPointerCapture(e.pointerId); } catch (err) {}
      // mark states so click handlers can ignore if drag happened
      svg.querySelectorAll('.state').forEach((p) => (p.__t1_isDragging = false));
    });

    svg.addEventListener('pointermove', (e) => {
      if (!dragging || !dragStart || !vbStart) return;
      const rect = svg.getBoundingClientRect();
      const dx = (dragStart.x - e.clientX) / rect.width * vbStart.w;
      const dy = (dragStart.y - e.clientY) / rect.height * vbStart.h;
      vb.x = vbStart.x + dx;
      vb.y = vbStart.y + dy;
      clampVB();
      setViewBox();
      // mark that a drag occurred so underlying click handlers ignore it
      svg.querySelectorAll('.state').forEach((p) => (p.__t1_isDragging = true));
    });

    svg.addEventListener('pointerup', (e) => {
      if (!dragging) return;
      dragging = false;
      try { svg.releasePointerCapture(e.pointerId); } catch (err) {}
      dragStart = null;
      vbStart = null;
      // small debounce already in setViewBox, but ensure emit after pointer end
      emitMapViewDebounced();
    });

    svg.addEventListener('pointercancel', () => {
      dragging = false; dragStart = null; vbStart = null;
    });

    // Double-click resets view
    svg.addEventListener('dblclick', (e) => {
      vb = { x: 0, y: 0, w: WIDTH, h: HEIGHT };
      setViewBox();
      clearSelection({ emit: true, push: false });
    });

    // Hook up control buttons
    const btnZoomIn = root.querySelector('#map-zoom-in');
    const btnZoomOut = root.querySelector('#map-zoom-out');
    const btnReset = root.querySelector('#map-reset');
    if (btnZoomIn) btnZoomIn.addEventListener('click', () => {
      const px = vb.x + vb.w / 2; const py = vb.y + vb.h / 2;
      const newW = Math.max(minW, vb.w * 0.92);
      const newH = (newW * HEIGHT) / WIDTH;
      const factor = newW / vb.w;
      vb.x = px - (px - vb.x) * factor;
      vb.y = py - (py - vb.y) * factor;
      vb.w = newW; vb.h = newH; clampVB(); setViewBox();
    });
    if (btnZoomOut) btnZoomOut.addEventListener('click', () => {
      const px = vb.x + vb.w / 2; const py = vb.y + vb.h / 2;
      const newW = Math.min(maxW, vb.w / 0.92);
      const newH = (newW * HEIGHT) / WIDTH;
      const factor = newW / vb.w;
      vb.x = px - (px - vb.x) * factor;
      vb.y = py - (py - vb.y) * factor;
      vb.w = newW; vb.h = newH; clampVB(); setViewBox();
    });
    if (btnReset) btnReset.addEventListener('click', () => {
      vb = { x: 0, y: 0, w: WIDTH, h: HEIGHT };
      setViewBox();
      clearSelection({ emit: true, push: false });
    });

    // Keep viewBox within the map bounds (avoid blank margins)
    function clampVB() {
      // Clamp horizontal
      if (vb.w <= WIDTH) {
        vb.x = Math.max(0, Math.min(vb.x, WIDTH - vb.w));
      } else {
        // center when zoomed out
        vb.x = (WIDTH - vb.w) / 2;
      }
      // Clamp vertical
      if (vb.h <= HEIGHT) {
        vb.y = Math.max(0, Math.min(vb.y, HEIGHT - vb.h));
      } else {
        vb.y = (HEIGHT - vb.h) / 2;
      }
    }

    // --- Keyboard accessibility: arrow keys to pan, +/- to zoom, 0/Home to reset ---
    svg.addEventListener('keydown', (evt) => {
      // Only respond when svg has focus
      const stepFraction = evt.shiftKey ? 0.25 : 0.08; // hold shift for larger jumps
      const zoomFactor = evt.shiftKey ? 0.8 : 0.92;
      let handled = false;

      if (evt.key === 'ArrowLeft') {
        vb.x -= vb.w * stepFraction; handled = true;
      } else if (evt.key === 'ArrowRight') {
        vb.x += vb.w * stepFraction; handled = true;
      } else if (evt.key === 'ArrowUp') {
        vb.y -= vb.h * stepFraction; handled = true;
      } else if (evt.key === 'ArrowDown') {
        vb.y += vb.h * stepFraction; handled = true;
      } else if (evt.key === '+' || evt.key === '=' ) {
        // zoom in centered on viewport center
        const px = vb.x + vb.w / 2;
        const py = vb.y + vb.h / 2;
        const newW = Math.max(minW, vb.w * zoomFactor);
        const newH = (newW * HEIGHT) / WIDTH;
        const factor = newW / vb.w;
        vb.x = px - (px - vb.x) * factor;
        vb.y = py - (py - vb.y) * factor;
        vb.w = newW; vb.h = newH;
        handled = true;
      } else if (evt.key === '-' ) {
        const px = vb.x + vb.w / 2;
        const py = vb.y + vb.h / 2;
        const newW = Math.min(maxW, vb.w / zoomFactor);
        const newH = (newW * HEIGHT) / WIDTH;
        const factor = newW / vb.w;
        vb.x = px - (px - vb.x) * factor;
        vb.y = py - (py - vb.y) * factor;
        vb.w = newW; vb.h = newH;
        handled = true;
      } else if (evt.key === '0' || evt.key === 'Home') {
        vb = { x: 0, y: 0, w: WIDTH, h: HEIGHT }; handled = true;
      }

      if (handled) {
        evt.preventDefault();
        setViewBox();
      }
    });

    window.addEventListener('t1:scope-changed', (event) => {
      const detail = event.detail || {};
      if (typeof detail.local === 'boolean') {
        localScopeActive = detail.local;
        syncCountyLayer();
      }
    });

    window.addEventListener('t1:locality-changed', (event) => {
      const detail = event.detail || {};
      const countyFips = detail.fipsCounty || detail.countyFips || detail.fips || null;
      const possibleState = detail.state ? String(detail.state).toUpperCase() : null;
      const stateCode = possibleState || (countyFips ? fipsToCode(String(countyFips).slice(0, 2)) : null);
      if (stateCode) {
        const stateFips = ((CODE_TO_FIPS[stateCode]) || (countyFips ? String(countyFips).slice(0, 2) : '')).padStart(2, '0');
        if (stateFips && (!selectedFips || selectedFips !== stateFips)) {
          selectState(stateFips, { emit: true, push: false });
        }
        currentStateCode = stateCode;
        syncCountyLayer();
      }
      if (countyFips) {
        ensureCountyLayerLoaded().then(() => {
          highlightCounty(String(countyFips));
        });
      } else {
        highlightCounty(null);
      }
    });

    syncCountyLayer();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initMapClient();
      // If a `state` query param is present on load, broadcast it so other panels sync.
      try {
        const params = new URL(window.location.href).searchParams;
const f = params.get('fips');
if (f) window.dispatchEvent(new CustomEvent('t1:state', { detail: { fips: f, code: fipsToCode(f) || null } }));
      } catch (err) {}
    });
  } else {
    initMapClient();
    try {
      const params = new URL(window.location.href).searchParams;
const f = params.get('fips');
if (f) window.dispatchEvent(new CustomEvent('t1:state', { detail: { fips: f, code: fipsToCode(f) || null } }));
    } catch (err) {}
  }

</script>
