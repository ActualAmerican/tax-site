---
import { geoAlbersUsa, geoPath } from 'd3-geo';
import { feature, mesh } from 'topojson-client';

export interface Props { }

// Canvas size used for projection and the SVG viewBox.
const WIDTH = 960;
const HEIGHT = 520;

// Server-side: pre-render SVG paths so the map appears without client bundling.
let statePaths = [];
let nationPath = '';
if (import.meta.env.SSR) {
  try {
    const fs = await import('fs');
    const path = await import('path');
    const topoPath = path.resolve(process.cwd(), 'public', 'topo', 'states-10m.json');
    const txt = fs.readFileSync(topoPath, 'utf-8');
    const topo = JSON.parse(txt);
    const states = feature(topo, topo.objects.states);
    const nation = mesh(topo, topo.objects.nation, (a, b) => a === b);

    const projection = geoAlbersUsa().fitSize([WIDTH, HEIGHT], states);
    const pathGen = geoPath(projection);

    statePaths = (states.features || []).map((f) => ({ d: pathGen(f), id: f.id }));
    if (nation) nationPath = pathGen(nation);
  } catch (err) {
    // If topo can't be read at build-time, leave paths empty and let client render later.
    console.error('Map SSR pre-render failed:', err);
  }
}
---
<div class="panel" data-t1-map>
  <div class="label"><strong>US Map</strong><span id="map-selected" class="badge">No state</span></div>
  <!-- Simple map controls: zoom in, zoom out, reset -->
  <div class="map-controls" role="toolbar" aria-label="Map controls">
    <button id="map-zoom-in" type="button" class="map-control-btn" aria-label="Zoom in" title="Zoom in">+</button>
    <button id="map-zoom-out" type="button" class="map-control-btn" aria-label="Zoom out" title="Zoom out">−</button>
    <button id="map-reset" type="button" class="map-control-btn" aria-label="Reset view" title="Reset view">⤢</button>
  </div>
  <svg
    width="100%"
    height="520"
    viewBox={`0 0 ${WIDTH} ${HEIGHT}`}
    preserveAspectRatio="xMidYMid meet"
    role="img"
    aria-label="Map of the United States"
    tabindex="0"
  >
    <!-- group we will pan/zoom by manipulating the SVG viewBox from client-side -->
    <g id="mapGroup">
      {statePaths.map(p => (
        <path d={p.d} data-fips={p.id} class="state" />
      ))}
      {nationPath ? <path d={nationPath} class="nation" /> : null}
    </g>
  </svg>
</div>

<!-- Lightweight client script to attach click handlers and dispatch state events. -->
<script type="module">
  // Parse the SVG viewBox at runtime to obtain WIDTH/HEIGHT so we don't need server-side injection here.
  // This avoids template interpolation issues and keeps the script robust when executed in the browser.

  function initMapClient() {
  const root = document.querySelector('[data-t1-map]');
  if (!root) return;
  const svg = root.querySelector('svg');
  if (!svg) return;
  // breadcrumb so we know the map script actually ran
  root.setAttribute('data-js', 'ready');
  // runtime diagnostic
  try { console.log('initMapClient', { href: location.href }); } catch (e) {}

const selBadge = root.querySelector('#map-selected');

// Minimal FIPS → code map so the badge shows 'CA' instead of '06'
const FIPS_TO_CODE = {
  '01':'AL','02':'AK','04':'AZ','05':'AR','06':'CA','08':'CO','09':'CT',
  '10':'DE','11':'DC','12':'FL','13':'GA','15':'HI','16':'ID','17':'IL',
  '18':'IN','19':'IA','20':'KS','21':'KY','22':'LA','23':'ME','24':'MD',
  '25':'MA','26':'MI','27':'MN','28':'MS','29':'MO','30':'MT','31':'NE',
  '32':'NV','33':'NH','34':'NJ','35':'NM','36':'NY','37':'NC','38':'ND',
  '39':'OH','40':'OK','41':'OR','42':'PA','44':'RI','45':'SC','46':'SD',
  '47':'TN','48':'TX','49':'UT','50':'VT','51':'VA','53':'WA','54':'WV',
  '55':'WI','56':'WY','72':'PR'
};
function fipsToCode(f) {
  if (!f) return null;
  const s = String(f);
  const two = s.length === 1 ? '0' + s : s;
  return FIPS_TO_CODE[two] || null;
}

// --- Selection & deep-link helpers ---
let selectedFips = null;

function selectState(fips, { emit = true, push = false } = {}) {
  if (!fips) return;

  // Toggle CSS class
  if (selectedFips) {
    const prev = svg.querySelector(`.state[data-fips="${selectedFips}"]`);
    if (prev) prev.classList.remove('state--selected');
  }
  const next = svg.querySelector(`.state[data-fips="${fips}"]`);
  if (next) next.classList.add('state--selected');
  selectedFips = fips;

// Update the badge text ("CA" or fallback to the FIPS)
const code = fipsToCode(fips);
if (selBadge) selBadge.textContent = code || fips;

  try { console.log('selectState', { fips, code }); } catch (e) {}
  // Ensure selected state is rendered above other shapes so its stroke is visible
  try {
    const group = svg.querySelector('#mapGroup');
    if (group && next) group.appendChild(next);
  } catch (e) {}

  // Update URL (?fips=XX) without reload
  try {
    const url = new URL(location.href);
    url.searchParams.set('fips', fips);
    if (push) {
      history.pushState({ fips }, '', url);
    } else {
      history.replaceState({ fips }, '', url);
    }
  } catch {}

  // Notify listeners
  if (emit) {
    window.dispatchEvent(new CustomEvent('t1:state', { detail: fips }));
  }
}

// Apply selection from URL on load
(function applyInitialSelection() {
  try {
    const url = new URL(location.href);
    const f = url.searchParams.get('fips');
    if (f) selectState(f, { emit: true, push: false });
  } catch {}
})();

// React to back/forward navigation
window.addEventListener('popstate', (e) => {
  const f = (e.state && e.state.fips) || (new URL(location.href)).searchParams.get('fips');
  if (f) selectState(f, { emit: true, push: false });
});

    // --- Click handlers (per-path + delegated fallback) ---

    // Ensure state paths receive pointer events (some browsers/styles may override)
    svg.querySelectorAll('.state').forEach((p) => { try { p.style.pointerEvents = 'auto'; } catch (e) {} });

    // Single delegated click handler (robust): use elementFromPoint as a fallback
    // and emit a single selection event. This avoids duplicate listeners and
    // is resilient to overlays or small layout differences.
    svg.addEventListener('click', (ev) => {
      try {
        // Prefer the event target. If an overlay sits on top of the svg (e.g. a
        // panel that visually overlaps), use elementsFromPoint to search the
        // stack for a .state element underneath.
        let path = null;
        if (ev.target instanceof Element) path = ev.target.closest ? ev.target.closest('.state') : null;

        if (!path) {
          // Look through the element stack under the pointer to find a .state
          // even if it's not the topmost element.
          if (document.elementsFromPoint) {
            const els = document.elementsFromPoint(ev.clientX, ev.clientY);
            for (const e of els) {
              if (!(e instanceof Element)) continue;
              const p = e.closest ? e.closest('.state') : (e.classList && e.classList.contains('state') ? e : null);
              if (p) { path = p; break; }
            }
            // debug overlay situation
                if (path && els[0] !== path) {
                  try { console.log('map:click overlay hit — top element', els[0], 'found state underneath', path); } catch (e) {}
                }
          } else {
            // fallback to elementFromPoint
            const el = document.elementFromPoint(ev.clientX, ev.clientY);
            path = el && el.closest ? el.closest('.state') : (el && el.classList && el.classList.contains('state') ? el : null);
          }
        }

        if (!path) return;
        const f = path.getAttribute('data-fips');
        if (!f) return;
        try { console.log('map:click', { fips: f }); } catch (e) {}
        selectState(f, { emit: true, push: true });
      } catch (err) {
        try { console.warn('map click handler error', err); } catch (e) {}
      }
    });

    // Pointer events for SVG states are provided via CSS (avoid inline style mutations).

  // --- Pan & Zoom using viewBox manipulation ---
  // read initial viewBox from the svg element (format: 'x y w h')
  const vbStr = svg.getAttribute('viewBox') || '0 0 960 520';
  const vbParts = vbStr.trim().split(/\s+/).map(Number);
  const [vbX, vbY, vbW, vbH] = vbParts;
  let vb = { x: vbX || 0, y: vbY || 0, w: vbW || 960, h: vbH || 520 };
  const WIDTH = vb.w;
  const HEIGHT = vb.h;
  const minW = WIDTH * 0.15; // max zoom-in
  const maxW = WIDTH * 1.8;  // max zoom-out

    // Debounced emitter so other components can listen to view changes without flooding.
    let _emitTimeout = null;
    function emitMapViewDebounced() {
      if (_emitTimeout) clearTimeout(_emitTimeout);
      _emitTimeout = setTimeout(() => {
        window.dispatchEvent(new CustomEvent('t1:map-view', { detail: { x: vb.x, y: vb.y, w: vb.w, h: vb.h } }));
        // Also detect center state once per debounce and emit t1:state so Breakdown updates
        detectCenterStateAndEmit();
        _emitTimeout = null;
      }, 80);
    }

    function setViewBox() {
      svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
      emitMapViewDebounced();
    }

    setViewBox();
    // Emit initial view synchronously once
    window.dispatchEvent(new CustomEvent('t1:map-view', { detail: { x: vb.x, y: vb.y, w: vb.w, h: vb.h } }));

    // Wheel to zoom (centered on pointer)
    svg.addEventListener('wheel', (evt) => {
      evt.preventDefault();
      const rect = svg.getBoundingClientRect();
      const cx = (evt.clientX - rect.left) / rect.width;
      const cy = (evt.clientY - rect.top) / rect.height;
      const px = vb.x + cx * vb.w;
      const py = vb.y + cy * vb.h;

      const zoomFactor = evt.deltaY < 0 ? 0.9 : 1.1;
      const newW = Math.max(minW, Math.min(maxW, vb.w * zoomFactor));
      const newH = (newW * HEIGHT) / WIDTH;
      const factor = newW / vb.w;

      vb.x = px - (px - vb.x) * factor;
      vb.y = py - (py - vb.y) * factor;
      vb.w = newW;
      vb.h = newH;
      clampVB();
      setViewBox();
    }, { passive: false });

    // Drag to pan (pointer events)
    let dragging = false;
    let dragStart = null;
    let vbStart = null;

    svg.addEventListener('pointerdown', (e) => {
      // Only start drag when primary button
      if (e.button !== 0) return;
      dragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      vbStart = { ...vb };
      try { svg.setPointerCapture(e.pointerId); } catch (err) {}
      // mark states so click handlers can ignore if drag happened
      svg.querySelectorAll('.state').forEach((p) => (p.__t1_isDragging = false));
    });

    svg.addEventListener('pointermove', (e) => {
      if (!dragging || !dragStart || !vbStart) return;
      const rect = svg.getBoundingClientRect();
      const dx = (dragStart.x - e.clientX) / rect.width * vbStart.w;
      const dy = (dragStart.y - e.clientY) / rect.height * vbStart.h;
      vb.x = vbStart.x + dx;
      vb.y = vbStart.y + dy;
      clampVB();
      setViewBox();
      // mark that a drag occurred so underlying click handlers ignore it
      svg.querySelectorAll('.state').forEach((p) => (p.__t1_isDragging = true));
    });

    svg.addEventListener('pointerup', (e) => {
      if (!dragging) return;
      dragging = false;
      try { svg.releasePointerCapture(e.pointerId); } catch (err) {}
      dragStart = null;
      vbStart = null;
      // small debounce already in setViewBox, but ensure emit after pointer end
      emitMapViewDebounced();
    });

    svg.addEventListener('pointercancel', () => {
      dragging = false; dragStart = null; vbStart = null;
    });

    // Double-click resets view
    svg.addEventListener('dblclick', (e) => {
      vb = { x: 0, y: 0, w: WIDTH, h: HEIGHT };
      setViewBox();
    });

    // Hook up control buttons
    const btnZoomIn = root.querySelector('#map-zoom-in');
    const btnZoomOut = root.querySelector('#map-zoom-out');
    const btnReset = root.querySelector('#map-reset');
    if (btnZoomIn) btnZoomIn.addEventListener('click', () => {
      const px = vb.x + vb.w / 2; const py = vb.y + vb.h / 2;
      const newW = Math.max(minW, vb.w * 0.92);
      const newH = (newW * HEIGHT) / WIDTH;
      const factor = newW / vb.w;
      vb.x = px - (px - vb.x) * factor;
      vb.y = py - (py - vb.y) * factor;
      vb.w = newW; vb.h = newH; clampVB(); setViewBox();
    });
    if (btnZoomOut) btnZoomOut.addEventListener('click', () => {
      const px = vb.x + vb.w / 2; const py = vb.y + vb.h / 2;
      const newW = Math.min(maxW, vb.w / 0.92);
      const newH = (newW * HEIGHT) / WIDTH;
      const factor = newW / vb.w;
      vb.x = px - (px - vb.x) * factor;
      vb.y = py - (py - vb.y) * factor;
      vb.w = newW; vb.h = newH; clampVB(); setViewBox();
    });
    if (btnReset) btnReset.addEventListener('click', () => {
      vb = { x: 0, y: 0, w: WIDTH, h: HEIGHT }; setViewBox();
    });

    // Keep viewBox within the map bounds (avoid blank margins)
    function clampVB() {
      // Clamp horizontal
      if (vb.w <= WIDTH) {
        vb.x = Math.max(0, Math.min(vb.x, WIDTH - vb.w));
      } else {
        // center when zoomed out
        vb.x = (WIDTH - vb.w) / 2;
      }
      // Clamp vertical
      if (vb.h <= HEIGHT) {
        vb.y = Math.max(0, Math.min(vb.y, HEIGHT - vb.h));
      } else {
        vb.y = (HEIGHT - vb.h) / 2;
      }
    }

    // Try to detect which state sits at the center of the current viewBox and dispatch a state event.
    let _lastCenterState = null;
    function detectCenterStateAndEmit() {
      try {
        const rect = svg.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const el = document.elementFromPoint(cx, cy);
        if (!el) return;
        const path = el.closest && el.closest('.state') ? el.closest('.state') : (el.classList && el.classList.contains('state') ? el : null);
        if (path) {
          const f = path.getAttribute('data-fips');
          if (f && f !== _lastCenterState) {
                        _lastCenterState = f;
            // Use selectState to update UI and ?fips= without pushing history
            selectState(f, { emit: true, push: false });
          }
        }
      } catch (err) {
        // ignore
      }
    }

    // --- Keyboard accessibility: arrow keys to pan, +/- to zoom, 0/Home to reset ---
    svg.addEventListener('keydown', (evt) => {
      // Only respond when svg has focus
      const stepFraction = evt.shiftKey ? 0.25 : 0.08; // hold shift for larger jumps
      const zoomFactor = evt.shiftKey ? 0.8 : 0.92;
      let handled = false;

      if (evt.key === 'ArrowLeft') {
        vb.x -= vb.w * stepFraction; handled = true;
      } else if (evt.key === 'ArrowRight') {
        vb.x += vb.w * stepFraction; handled = true;
      } else if (evt.key === 'ArrowUp') {
        vb.y -= vb.h * stepFraction; handled = true;
      } else if (evt.key === 'ArrowDown') {
        vb.y += vb.h * stepFraction; handled = true;
      } else if (evt.key === '+' || evt.key === '=' ) {
        // zoom in centered on viewport center
        const px = vb.x + vb.w / 2;
        const py = vb.y + vb.h / 2;
        const newW = Math.max(minW, vb.w * zoomFactor);
        const newH = (newW * HEIGHT) / WIDTH;
        const factor = newW / vb.w;
        vb.x = px - (px - vb.x) * factor;
        vb.y = py - (py - vb.y) * factor;
        vb.w = newW; vb.h = newH;
        handled = true;
      } else if (evt.key === '-' ) {
        const px = vb.x + vb.w / 2;
        const py = vb.y + vb.h / 2;
        const newW = Math.min(maxW, vb.w / zoomFactor);
        const newH = (newW * HEIGHT) / WIDTH;
        const factor = newW / vb.w;
        vb.x = px - (px - vb.x) * factor;
        vb.y = py - (py - vb.y) * factor;
        vb.w = newW; vb.h = newH;
        handled = true;
      } else if (evt.key === '0' || evt.key === 'Home') {
        vb = { x: 0, y: 0, w: WIDTH, h: HEIGHT }; handled = true;
      }

      if (handled) {
        evt.preventDefault();
        setViewBox();
      }
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initMapClient();
      // If a `state` query param is present on load, broadcast it so other panels sync.
      try {
        const params = new URL(window.location.href).searchParams;
const f = params.get('fips');
if (f) window.dispatchEvent(new CustomEvent('t1:state', { detail: f }));
      } catch (err) {}
    });
  } else {
    initMapClient();
    try {
      const params = new URL(window.location.href).searchParams;
const f = params.get('fips');
if (f) window.dispatchEvent(new CustomEvent('t1:state', { detail: f }));
    } catch (err) {}
  }

</script>



