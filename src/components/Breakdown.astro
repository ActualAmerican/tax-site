---
/* Breakdown panel (bundled module import) */
const { initialState = 'CA', compareSlot } = Astro.props;
const slot = compareSlot ?? 'solo';
---
<div
  class="panel stack"
  data-t1-breakdown
  data-slot={slot}
  data-state={initialState}
>
  <div class="label">
    <strong>Breakdown</strong><span id="bd-state">{initialState}</span>
  </div>

  <div id="chart" class="bar" aria-label="Stacked tax burden bar"></div>

  <table id="tbl" class="table-full">
    <thead>
      <tr>
        <th>Category</th>
        <th class="text-right">Amount</th>
        <th class="text-right">%</th>
      </tr>
    </thead>
    <tbody></tbody>
    <tfoot>
      <tr>
        <th>Total</th>
        <th id="tot" class="text-right"></th>
        <th id="eff" class="text-right"></th>
      </tr>
    </tfoot>
  </table>

  <div class="label">
    <a class="badge" id="export" href={`/report?state=${initialState}`}>Export PDF</a>
  </div>
</div>

<!-- Small client script to listen for state change events and update this panel's UI/export link -->
<script type="module">
  (function () {
    // Find this panel reliably when executed as a module
    const root =
      (document.currentScript && document.currentScript.previousElementSibling) ||
      document.querySelector('[data-t1-breakdown]');
    if (!root) return;

    // Determine which compare slot this panel represents
    const slot = root.getAttribute('data-slot') || 'solo';

    const stateLabel = root.querySelector('#bd-state');
    const exportLink = root.querySelector('#export');

    // Minimal FIPS -> USPS code map (add more if needed)
    const FIPS_TO_CODE = {
      '01': 'AL','02': 'AK','04': 'AZ','05': 'AR','06': 'CA','08': 'CO','09': 'CT',
      '10': 'DE','11': 'DC','12': 'FL','13': 'GA','15': 'HI','16': 'ID','17': 'IL',
      '18': 'IN','19': 'IA','20': 'KS','21': 'KY','22': 'LA','23': 'ME','24': 'MD',
      '25': 'MA','26': 'MI','27': 'MN','28': 'MS','29': 'MO','30': 'MT','31': 'NE',
      '32': 'NV','33': 'NH','34': 'NJ','35': 'NM','36': 'NY','37': 'NC','38': 'ND',
      '39': 'OH','40': 'OK','41': 'OR','42': 'PA','44': 'RI','45': 'SC','46': 'SD',
      '47': 'TN','48': 'TX','49': 'UT','50': 'VT','51': 'VA','53': 'WA','54': 'WV',
      '55': 'WI','56': 'WY','72': 'PR'
    };

    function normalizeStateCode(input) {
      // Accept 'CA' or '06' and normalize to 'CA'
      if (!input) return null;
      const s = String(input).toUpperCase();
      if (s.length === 2 && /[A-Z]{2}/.test(s)) return s;
      if (s.length <= 2) {
        const two = s.padStart(2, '0');
        return FIPS_TO_CODE[two] || null;
      }
      return null;
    }

    let latestInputs = {
  filingStatus: 'single',
  income: 60000,
  homeowner: true,
  homeValue: 300000,
  miles: 12000,
  mpg: 28,
  spendingShare: 0.60,
  taxableShare: 0.55,
  includeFederal: false,
  ltcg: 0
};

    function renderBreakdownRows(stateRows, federalRows, total) {
  const tbody = root.querySelector('tbody');
  if (!tbody) return;
  tbody.innerHTML = '';

  // group header row factory
  const addGroupHeader = (label) => {
    const tr = document.createElement('tr');
    tr.className = 'group';
    const th = document.createElement('th');
    th.colSpan = 3;
    th.textContent = label;
    tr.appendChild(th);
    tbody.appendChild(tr);
  };

  // row factory
  const addRow = (r) => {
    const tr = document.createElement('tr');
    const tdCat = document.createElement('td'); tdCat.textContent = r.label;
    const tdAmt = document.createElement('td'); tdAmt.className = 'text-right'; tdAmt.textContent = r.amount;
    const tdPct = document.createElement('td'); tdPct.className = 'text-right'; tdPct.textContent = r.pct;
    tr.appendChild(tdCat); tr.appendChild(tdAmt); tr.appendChild(tdPct);
    tbody.appendChild(tr);
  };

  if (stateRows.length) {
    addGroupHeader('State taxes');
    stateRows.forEach(addRow);
  }
  if (federalRows.length) {
    addGroupHeader('Federal taxes');
    federalRows.forEach(addRow);
  }
}

    // Cache pack data to avoid refetching
    let _packCache = null;
    async function loadPack() {
      if (_packCache) return _packCache;
      try {
        const res = await fetch('/data/packs/2025.1.0.json');
        if (!res.ok) throw new Error('pack fetch failed');
        _packCache = await res.json();
        return _packCache;
      } catch (err) {
        console.warn('Breakdown: failed to load pack', err);
        _packCache = null;
        return null;
      }
    }

    function findRow(arr, state) {
      if (!arr) return null;
      return (arr.find(r => String(r.state).toUpperCase() === String(state).toUpperCase()) || null);
    }

function isStub(r, kind) {
  if (!r) return true;
  if (r.__stub === true || r.stub === true) return true;
  // Heuristics per metric: consider "missing" if essential fields aren’t present
  if (kind === 'income') {
    if (r.has_income_tax === false) return true;
    const hasBrackets = Array.isArray(r.brackets) && r.brackets.length > 0;
    const hasFlat = typeof r.flat === 'number';
    return !(hasBrackets || hasFlat);
  }
  if (kind === 'sales') {
    return !(typeof r.combined_rate === 'number');
  }
  if (kind === 'property') {
    return !(typeof r.effective_rate === 'number');
  }
  return false;
}

function computeFederalTotals(pack, inputs) {
  const fed = pack && pack.federal ? pack.federal : null;
  const fs  = (inputs.filingStatus || 'single').toLowerCase();
  const inc = Number(inputs.income) || 0;
  const ltcg = Number(inputs.ltcg) || 0;

  // Income tax via brackets
  function taxFromBrackets(def, taxable, stdDedOverride) {
    if (!def) return 0;
    const std = stdDedOverride != null ? stdDedOverride : (def.standard_deduction || 0);
    const base = Math.max(0, taxable - std);
    let tax = 0, prev = 0;
    const brackets = def.brackets || [];
    for (const b of brackets) {
      const cap = (b.up_to == null) ? base : b.up_to;
      const slice = Math.max(0, Math.min(base, cap) - prev);
      tax += slice * (b.rate || 0);
      prev = cap;
      if (prev >= base) break;
    }
    return Math.round(tax);
  }

  const incomeDef = fed && fed.income && (fed.income[fs] || fed.income.single) || null;
  const federalIncome = taxFromBrackets(incomeDef, inc);

  // Payroll (employee share)
  const pr = fed && fed.payroll || {};
  const ssBase   = pr.ss_wage_base ?? 168600;
  const ssRate   = pr.ss_rate ?? 0.062;
  const mediRate = pr.medicare_rate ?? 0.0145;
  const addRate  = pr.addl_medicare_rate ?? 0.009;
  const addThreshMap = pr.addl_threshold || { single: 200000, married: 250000 };
  const addThresh = addThreshMap[fs] ?? 200000;

  const ss   = Math.min(inc, ssBase) * ssRate;
  const medi = inc * mediRate + Math.max(0, inc - addThresh) * addRate;
  const payroll = Math.round(ss + medi);

  // LTCG
  let ltcgTax = 0;
  const cgDef = fed && fed.ltcg && (fed.ltcg[fs] || fed.ltcg.single) || null;
  if (cgDef && ltcg > 0) {
    let prev = 0;
    const brackets = cgDef.brackets || [];
    for (const b of brackets) {
      const cap = (b.up_to == null) ? ltcg : b.up_to;
      const slice = Math.max(0, Math.min(ltcg, cap) - prev);
      ltcgTax += slice * (b.rate || 0);
      prev = cap;
      if (prev >= ltcg) break;
    }
    ltcgTax = Math.round(ltcgTax);
  }

  return { federalIncome, payroll, ltcgTax, total: federalIncome + payroll + ltcgTax };
}

    async function computeDemoBreakdown(code) {
  const inc  = Number(latestInputs.income) || 0;
  const hv   = Number(latestInputs.homeValue) || 0;
  const home = !!latestInputs.homeowner;

  const pack = await loadPack();

  // ----- STATE CATEGORIES -----
let stIncome = 0, stIncomeMissing = false;
// Income tax (state)
if (pack && pack.income) {
  const row = findRow(pack.income, code);
  if (!row || isStub(row, 'income')) {
    stIncomeMissing = true;
  } else if (row.has_income_tax) {
    const std = row.standard_deduction || 0;
    const taxable = Math.max(0, inc - std);
    if (typeof row.flat === 'number') {
      stIncome = Math.round(taxable * row.flat);
    } else {
      const brackets = row.brackets || [];
      let prev = 0;
      for (const b of brackets) {
        const cap = (b.up_to == null) ? taxable : b.up_to;
        const slice = Math.max(0, Math.min(taxable, cap) - prev);
        stIncome += Math.round(slice * (b.rate || 0));
        prev = cap;
        if (prev >= taxable) break;
      }
    }
  } else {
    stIncomeMissing = true;
  }
} else {
  stIncomeMissing = true;
}

let stSales = 0, stSalesMissing = false;
// Sales tax
if (pack && pack.sales) {
  const srow = findRow(pack.sales, code);
  if (!srow || isStub(srow, 'sales')) {
    stSalesMissing = true;
  } else {
    const rate = srow.combined_rate || 0;
    const spendingShare = Number(latestInputs.spendingShare) || 0.6;
    stSales = Math.round(inc * spendingShare * rate);
  }
} else {
  stSalesMissing = true;
}

let stProperty = 0, stPropertyMissing = false;
// Property tax
if (pack && pack.property) {
  const prow = findRow(pack.property, code);
  if (!prow || isStub(prow, 'property')) {
    stPropertyMissing = true;
  } else {
    const eff = prow.effective_rate || 0;
    stProperty = Math.round(hv * eff);
  }
} else {
  stPropertyMissing = true;
}

  // ----- FEDERAL (optional) -----
  let fedIncome = 0, fedPayroll = 0, fedLTCG = 0;
  if (latestInputs.includeFederal) {
    const f = computeFederalTotals(pack, latestInputs);
    fedIncome  = f.federalIncome;
    fedPayroll = f.payroll;
    fedLTCG    = f.ltcgTax;
  }

  // Build grouped rows (null means “no data” → show em-dash)
const stateNumeric = [
  { label: 'Income tax',   value: stIncomeMissing   ? null : stIncome },
  { label: 'Sales tax',    value: stSalesMissing    ? null : stSales },
  { label: 'Property tax', value: stPropertyMissing ? null : stProperty },
];

const federalNumeric = [];
if (latestInputs.includeFederal) {
  federalNumeric.push({ label: 'Federal income',     value: fedIncome });
  federalNumeric.push({ label: 'Payroll (employee)', value: fedPayroll });
  if (fedLTCG > 0) federalNumeric.push({ label: 'LTCG', value: fedLTCG });
}

const total = [...stateNumeric, ...federalNumeric]
  .reduce((a, r) => a + (r.value ?? 0), 0);

const fmt = (v) => '$' + (Number(v || 0)).toLocaleString();

const toDisplay = (arr) => arr.map(r => ({
  label:  r.label,
  amount: r.value == null ? '—' : fmt(r.value),
  pct:    r.value == null ? '—' : ((r.value / Math.max(1, total)) * 100).toFixed(0) + '%'
}));

const stateDisplay   = toDisplay(stateNumeric);
const federalDisplay = toDisplay(federalNumeric);

const tot = root.querySelector('#tot');
const eff = root.querySelector('#eff');
if (tot) tot.textContent = fmt(total);
if (eff) eff.textContent = ((total / Math.max(1, inc)) * 100).toFixed(1) + '%';

renderBreakdownRows(stateDisplay, federalDisplay, total);
}

    function updateState(val) {
      const code = normalizeStateCode(val);
      try { console.log('Breakdown:updateState raw', val, 'normalized', code); } catch (e) {}

      // Read current inputs directly from the page to ensure we use the
      // most recent committed values when switching states. This avoids
      // requiring the user to change an input to force a recompute.
      // helper to parse formatted numeric strings (commas, $ etc.)
      function _parseNum(v) { try { return Number(String(v).replace(/[^0-9.\-\.]/g, '')) || 0; } catch (e) { return 0; } }
      try {
        const form = document.querySelector('form[aria-label="Tax inputs"]');
if (form) {
  const get = id => form.querySelector('#' + id);
  const incEl  = get('inc');
  const hvEl   = get('hv');
  const hoEl   = get('ho');
  const fsEl   = get('fs');
  const ssEl   = get('ss');
  const tsEl   = get('ts');
  const fedEl  = get('fed');
  const ltcgEl = get('ltcg');

  latestInputs.income        = incEl  ? _parseNum(incEl.value)  : latestInputs.income;
  latestInputs.homeValue     = hvEl   ? _parseNum(hvEl.value)   : latestInputs.homeValue;
  latestInputs.homeowner     = hoEl   ? (hoEl.value === '1')    : latestInputs.homeowner;
  latestInputs.filingStatus  = fsEl   ? (fsEl.value || 'single') : latestInputs.filingStatus;
  latestInputs.spendingShare = ssEl   ? (+ssEl.value)           : latestInputs.spendingShare;
  latestInputs.taxableShare  = tsEl   ? (+tsEl.value)           : latestInputs.taxableShare;
  latestInputs.includeFederal= fedEl  ? (fedEl.value === '1')   : latestInputs.includeFederal;
  latestInputs.ltcg          = ltcgEl ? _parseNum(ltcgEl.value) : latestInputs.ltcg;
}
      } catch (err) { /* ignore */ }

      if (!code) return;

      root.setAttribute('data-state', code);
      if (stateLabel) stateLabel.textContent = code;
      if (exportLink) exportLink.setAttribute('href', `/report?state=${code}`);

      // Recompute demo breakdown with the latest inputs
      computeDemoBreakdown(code);
    }

    // Generic event: map clicks dispatch 't1:state' with FIPS; normalize and update
    window.addEventListener('t1:state', (e) => {
      const s = e.detail;
      try { console.log('Breakdown: received t1:state', s); } catch (e) {}
      if (!s) return;
      if (slot === 'solo') updateState(s);
    });

    // Listen for input changes so breakdown can update live
    window.addEventListener('t1:inputs', (e) => {
  try {
    const d = e.detail || {};
    latestInputs.filingStatus   = d.filingStatus   ?? latestInputs.filingStatus;
    latestInputs.income         = d.income         ?? latestInputs.income;
    latestInputs.homeValue      = d.homeValue      ?? latestInputs.homeValue;
    latestInputs.homeowner      = (typeof d.homeowner === 'boolean') ? d.homeowner : latestInputs.homeowner;
    latestInputs.miles          = d.miles          ?? latestInputs.miles;
    latestInputs.mpg            = d.mpg            ?? latestInputs.mpg;
    latestInputs.spendingShare  = d.spendingShare  ?? latestInputs.spendingShare;
    latestInputs.taxableShare   = d.taxableShare   ?? latestInputs.taxableShare;
    latestInputs.includeFederal = (typeof d.includeFederal === 'boolean') ? d.includeFederal : latestInputs.includeFederal;
    latestInputs.ltcg           = d.ltcg           ?? latestInputs.ltcg;

    // Recompute breakdown for current state
    const cur = root.getAttribute('data-state') || stateLabel.textContent;
    computeDemoBreakdown(cur);
  } catch (err) { console.warn('Breakdown t1:inputs handler error', err); }
});

    // Compare slots (future)
    window.addEventListener('t1:state-left',  (e) => { if (slot === 'left')  updateState(e.detail); });
    window.addEventListener('t1:state-right', (e) => { if (slot === 'right') updateState(e.detail); });

    // Direct API for programmatic control
    root.addEventListener('t1:set-state', (ev) => { if (ev.detail) updateState(ev.detail); });

    // Initialize from URL (?fips=06 or ?state=CA)
    try {
      const url = new URL(location.href);
      const fips  = url.searchParams.get('fips');
      const state = url.searchParams.get('state');
      updateState(state || fips);
    } catch {}
  })();
  // Recompute when inputs change (even if the map selection stays the same)
window.addEventListener('t1:inputs', () => {
  // re-emit a local event most compute modules already listen for
  document.querySelector('[data-t1-breakdown]')?.dispatchEvent(new CustomEvent('t1:recompute'));
});

</script>
