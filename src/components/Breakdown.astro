---
/* Breakdown panel (bundled module import) */
const { initialState = null, compareSlot } = Astro.props;
const slot = compareSlot ?? 'solo';
const initialCode = initialState ?? '';
const initialLabel = initialState ?? '--';
const hasInitial = Boolean(initialState);
const exportHref = hasInitial ? `/report?state=${initialCode}` : '#';
const compareHref = hasInitial ? `/compare?a=${initialCode}` : '#';
---
<div
  class="panel stack"
  data-t1-breakdown
  data-slot={slot}
  data-state={initialCode}
>
  <!-- Header with live chips + toolbar -->
  <div class="header--space">
    <div class="stack--row">
      <strong>Breakdown</strong>
      <span id="bd-state" class="badge" role="status" aria-live="polite">{initialLabel}</span>
      <span class="chip" id="chip-total">--</span>
      <span class="chip" id="chip-eff">--</span>
    </div>
    <div class="toolbar">
      <a class={'badge' + (hasInitial ? '' : ' is-disabled')} id="bd-export" href={exportHref} aria-disabled={!hasInitial}>Export PDF</a>
      <a class={'badge' + (hasInitial ? '' : ' is-disabled')} id="bd-compare" href={compareHref} aria-disabled={!hasInitial}>Compare</a>
      <button class="badge" id="bd-pie" type="button" title="Open pie chart">Open chart</button>
      <button class="badge" id="bd-copy" type="button">Copy link</button>
    </div>
  </div>

  <!-- Filled stacked bar -->

  <div id="chart" class="bar" aria-label="Stacked tax burden bar"></div>

  <table id="tbl" class="table-full">
    <thead>
      <tr>
        <th>Category</th>
        <th class="text-right">Amount</th>
        <th class="text-right">%</th>
      </tr>
    </thead>
    <tbody></tbody>
    <tfoot>
      <tr>
        <th>Total</th>
        <th id="tot" class="text-right"></th>
        <th id="eff" class="text-right"></th>
      </tr>
    </tfoot>
  </table>
  <div id="bd-error" class="panel error no-print" hidden></div>
</div>

<!-- Client: listens for state & inputs, renders rows, stacked bar, and manages toolbar -->
<script type="module">
(function () {
  // Panel root
  const root =
    (document.currentScript && document.currentScript.previousElementSibling) ||
    document.querySelector('[data-t1-breakdown]');
  if (!root) return;

  const slot       = root.getAttribute('data-slot') || 'solo';
  const stateLabel = root.querySelector('#bd-state');
  const exportLink = root.querySelector('#bd-export');
  const compareLink= root.querySelector('#bd-compare');
  const copyBtn    = root.querySelector('#bd-copy');
  const pieBtn     = root.querySelector('#bd-pie');
  const chipTotal  = root.querySelector('#chip-total');
  const chipEff    = root.querySelector('#chip-eff');
  const totEl      = root.querySelector('#tot');
  const effEl      = root.querySelector('#eff');
  const barEl      = root.querySelector('#chart');
  let _lastSegments = []; // current stacked-bar segments used by the pie modal

  // Loading and empty states
  const _tbody = root.querySelector('tbody');
  function setPlaceholderRow(message) {
    if (!_tbody) return;
    _tbody.innerHTML = `<tr class="loading"><td colspan="3">${message}</td></tr>`;
    renderStackedBar([], 0);
    _lastSegments = [];
  }
  function setLoadingRow() {
    setPlaceholderRow('Loading latest tax data...');
  }
  function setEmptyRow() {
    setPlaceholderRow('Select a state to view its breakdown.');
  }
  let currentState = root.getAttribute('data-state') || '';
  const initialCodeAttr = currentState;
  if (currentState) {
    setLoadingRow();
  } else {
    setEmptyRow();
  }

  const initialScopes = slot === 'solo'
    ? { local: false, state: false, federal: false }
    : { local: false, state: true, federal: true };
  const scopeFlags = { ...initialScopes };
  function applyToolbarState() {
    const active = Boolean(currentState);
    if (stateLabel) stateLabel.textContent = active ? currentState : '--';
    if (!active && chipTotal) chipTotal.textContent = '--';
    if (!active && chipEff)   chipEff.textContent   = '--';
    if (!active && totEl) totEl.textContent = '--';
    if (!active && effEl) effEl.textContent = '--';
    if (exportLink) {
      exportLink.classList.toggle('is-disabled', !active);
      exportLink.setAttribute('aria-disabled', String(!active));
      exportLink.setAttribute('href', active ? `/report?state=${currentState}` : '#');
    }
    if (compareLink) {
      compareLink.classList.toggle('is-disabled', !active);
      compareLink.setAttribute('aria-disabled', String(!active));
      compareLink.setAttribute('href', active ? buildCompareHref(currentState) : '#');
      compareLink.textContent = 'Compare';
    }
  }
  applyToolbarState();


  // Lightweight analytics hooks (safe no-ops if module missing)
  try {
    if (copyBtn) copyBtn.addEventListener('click', async () => {
      try { (await import('../lib/analytics.ts')).track('copy_link', { page: slot, state: currentState }); } catch {}
    });
    if (pieBtn) pieBtn.addEventListener('click', async () => {
      try { (await import('../lib/analytics.ts')).track('open_chart', { page: slot, state: currentState }); } catch {}
    });
    if (exportLink) exportLink.addEventListener('click', async () => {
      try { (await import('../lib/analytics.ts')).track('export_pdf', { page: slot, state: currentState }); } catch {}
    });
  } catch {}

  // Normalize toolbar text in case SSR encoding artifacts slip in.
  if (compareLink) compareLink.textContent = 'Compare';
  if (chipTotal && (!chipTotal.textContent || chipTotal.textContent.trim() === '')) chipTotal.textContent = '--';
  if (chipEff && (!chipEff.textContent || chipEff.textContent.trim() === '')) chipEff.textContent = '--';

  // FIPS to USPS map
  const FIPS_TO_CODE = {
    '01':'AL','02':'AK','04':'AZ','05':'AR','06':'CA','08':'CO','09':'CT','10':'DE','11':'DC','12':'FL','13':'GA',
    '15':'HI','16':'ID','17':'IL','18':'IN','19':'IA','20':'KS','21':'KY','22':'LA','23':'ME','24':'MD','25':'MA',
    '26':'MI','27':'MN','28':'MS','29':'MO','30':'MT','31':'NE','32':'NV','33':'NH','34':'NJ','35':'NM','36':'NY',
    '37':'NC','38':'ND','39':'OH','40':'OK','41':'OR','42':'PA','44':'RI','45':'SC','46':'SD','47':'TN','48':'TX',
    '49':'UT','50':'VT','51':'VA','53':'WA','54':'WV','55':'WI','56':'WY','72':'PR'
  };
  function normalizeStateCode(input) {
    if (!input) return null;
    if (typeof input === 'object') {
      if (input.code) return normalizeStateCode(input.code);
      if (input.fips) return normalizeStateCode(input.fips);
    }
    const s = String(input).toUpperCase();
    if (/^[A-Z]{2}$/.test(s)) return s;
    const two = s.padStart(2,'0');
    return FIPS_TO_CODE[two] || null;
  }

  // Color mapping for categories (matches tokens.css)
  const COLOR = {
    income:      'var(--t1-income)',
    sales:       'var(--t1-sales)',
    property:    'var(--t1-property)',
    excise:      'var(--t1-excise)',
    fuel:        'var(--t1-fuel)',
    fed_income:  'var(--t1-fed-income)',
    payroll:     'var(--t1-payroll)',
    ltcg:        'var(--t1-ltcg)',
    local_sales:    'var(--t1-local-sales)',
    local_property: 'var(--t1-local-property)',
    local_services: 'var(--t1-local-service)'
  };
  function colorForKey(k){ return COLOR[k] || 'var(--accent)'; }

  // Latest inputs seen by this panel
  let latestInputs = {
    filingStatus: 'single',
    income: 60000,
    homeowner: true,
    homeValue: 300000,
    miles: 12000,
    mpg: 28,
    spendingShare: 0.60,
    taxableShare: 0.55,
    includeFederal: true,
    ltcg: 0,
    scopes: { ...initialScopes },
    locality: {}
  };
  scopeFlags.local = latestInputs.scopes.local;
  scopeFlags.state = latestInputs.scopes.state;
  scopeFlags.federal = latestInputs.scopes.federal;

  // Ignore stale async renders
  let _seq = 0;

  // Pack fetch/cache (prefer globals seeded elsewhere)
  let _packCache = null;

  function primePackFromGlobals() {
    if (_packCache) return _packCache;
    try {
      const w = typeof window !== 'undefined' ? window : null;
      const seeded = w ? w.__T1_PACK__ || w.__t1_pack || null : null;
      if (seeded && typeof seeded === 'object') {
        _packCache = seeded;
        if (w && !w.__T1_PACK__) w.__T1_PACK__ = seeded;
        if (w && !w.__t1_pack) w.__t1_pack = seeded;
      }
    } catch (err) {
      try { console.warn('Breakdown: failed to read preloaded pack', err); } catch (_) {}
    }
    return _packCache;
  }
  primePackFromGlobals();

async function loadPack() {
  if (_packCache) return _packCache;
  primePackFromGlobals();
  if (_packCache) return _packCache;

  // 1) Prefer the SSR-injected JSON (fast, always present)
  try {
    if (window.__T1_PACK__ && typeof window.__T1_PACK__ === 'object') {
      _packCache = window.__T1_PACK__;
      return _packCache;
    }
    const scriptEl = document.getElementById('t1-pack');
    if (scriptEl && scriptEl.textContent) {
      _packCache = JSON.parse(scriptEl.textContent);
      window.__T1_PACK__ = _packCache;
      return _packCache;
    }
  } catch (e) {
    console.warn('Breakdown: pack inject parse failed', e);
  }

  // 2) Fallback: try to fetch if the file is being served
  const candidates = [
    '/data/packs/2025.1.0.composed.json',
    '/data/packs/2025.1.0.json',
  ];
  for (const url of candidates) {
    try {
      const res = await fetch(url, { cache: 'no-store' });
      if (res.ok) {
        _packCache = await res.json();
        window.__T1_PACK__ = _packCache;
        return _packCache;
      }
    } catch (_) {}
  }

  console.warn('Breakdown: no pack available (inject or fetch failed)');
  return null;
}

  function findRow(arr, state) {
    if (!arr) return null;
    return (arr.find(r => String(r.state).toUpperCase() === String(state).toUpperCase()) || null);
  }

  function isStub(r, kind) {
    if (!r) return true;
    if (r.__stub === true || r.stub === true) return true;
    if (kind === 'income') {
      if (r.has_income_tax === false) return false;
      const hasBrackets = Array.isArray(r.brackets) && r.brackets.length > 0;
      const hasFlat = typeof r.flat === 'number';
      return !(hasBrackets || hasFlat);
    }
    if (kind === 'sales')    return !(typeof r.combined_rate  === 'number');
    if (kind === 'property') return !(typeof r.effective_rate === 'number');
    return false;
  }

  function computeFederalTotals(pack, inputs) {
    const fed = pack && pack.federal ? pack.federal : null;
    const fs  = (inputs.filingStatus || 'single').toLowerCase();
    const inc = Number(inputs.income) || 0;
    const ltcg = Number(inputs.ltcg) || 0;

    function taxFromBrackets(def, taxable, stdDedOverride) {
      if (!def) return 0;
      const std = stdDedOverride != null ? stdDedOverride : (def.standard_deduction || 0);
      const base = Math.max(0, taxable - std);
      let tax = 0, prev = 0;
      const brackets = def.brackets || [];
      for (const b of brackets) {
        const cap = (b.up_to == null) ? base : b.up_to;
        const slice = Math.max(0, Math.min(base, cap) - prev);
        tax += slice * (b.rate || 0);
        prev = cap;
        if (prev >= base) break;
      }
      return Math.round(tax);
    }

    const incomeDef = fed && fed.income && (fed.income[fs] || fed.income.single) || null;
    const federalIncome = taxFromBrackets(incomeDef, inc);

    const pr = fed && fed.payroll || {};
    const ssBase   = pr.ss_wage_base ?? 168600;
    const ssRate   = pr.ss_rate ?? 0.062;
    const mediRate = pr.medicare_rate ?? 0.0145;
    const addRate  = pr.addl_medicare_rate ?? 0.009;
    const addThreshMap = pr.addl_threshold || { single: 200000, married: 250000 };
    const addThresh = addThreshMap[fs] ?? 200000;

    const ss   = Math.min(inc, ssBase) * ssRate;
    const medi = inc * mediRate + Math.max(0, inc - addThresh) * addRate;
    const payroll = Math.round(ss + medi);

    let ltcgTax = 0;
    const cgDef = fed && fed.ltcg && (fed.ltcg[fs] || fed.ltcg.single) || null;
    if (cgDef && ltcg > 0) {
      let prev = 0;
      const brackets = cgDef.brackets || [];
      for (const b of brackets) {
        const cap = (b.up_to == null) ? ltcg : b.up_to;
        const slice = Math.max(0, Math.min(ltcg, cap) - prev);
        ltcgTax += slice * (b.rate || 0);
        prev = cap;
        if (prev >= ltcg) break;
      }
      ltcgTax = Math.round(ltcgTax);
    }

    return {
      federalIncome,
      payroll,
      ltcgTax,
      total: federalIncome + payroll + ltcgTax,
      payrollAssumptions: { ssBase, ssRate, mediRate, addRate, addThresh }
    };
  }

  // Utilities
  const fmt = (v) => '$' + (Number(v || 0)).toLocaleString();
  function pctOf(part, total){ return ((part / Math.max(1,total)) * 100).toFixed(0) + '%'; }

function renderBreakdownRows(localRows, stateRows, federalRows, totals) {
    const tbody = root.querySelector('tbody');
    if (!tbody) return;
    tbody.innerHTML = '';

    const safeTotals = {
      local: totals && totals.local ? totals.local : { amount: '--', pct: '--' },
      state: totals && totals.state ? totals.state : { amount: '--', pct: '--' },
      federal: totals && totals.federal ? totals.federal : { amount: '--', pct: '--' }
    };

    const addGroupHeader = (label) => {
      const tr = document.createElement('tr');
      tr.className = 'group';
      const th = document.createElement('th');
      th.colSpan = 3;
      th.textContent = label;
      tr.appendChild(th);
      tbody.appendChild(tr);
    };

    const addRow = (r) => {
      const tr = document.createElement('tr');
      const tdCat = document.createElement('td');
      if (r.title) tdCat.innerHTML = `<span title="${r.title.replace(/"/g, '&quot;')}">${r.label}</span>`;
      else         tdCat.textContent = r.label;
      const tdAmt = document.createElement('td'); tdAmt.className = 'text-right'; tdAmt.textContent = r.amount;
      const tdPct = document.createElement('td'); tdPct.className = 'text-right'; tdPct.textContent = r.pct;
      tr.appendChild(tdCat); tr.appendChild(tdAmt); tr.appendChild(tdPct);
      tbody.appendChild(tr);
    };

    const addSubtotal = (label, amount, pct) => {
      const tr = document.createElement('tr');
      tr.className = 'subtotal';
      const th = document.createElement('th'); th.textContent = label;
      const tdAmt = document.createElement('td'); tdAmt.className = 'text-right'; tdAmt.textContent = amount;
      const tdPct = document.createElement('td'); tdPct.className = 'text-right'; tdPct.textContent = pct;
      tr.appendChild(th); tr.appendChild(tdAmt); tr.appendChild(tdPct);
      tbody.appendChild(tr);
    };

    if (localRows.length) {
      addGroupHeader('Local taxes');
      localRows.forEach(addRow);
      addSubtotal('Local subtotal', safeTotals.local.amount, safeTotals.local.pct);
    }
    if (stateRows.length) {
      addGroupHeader('State taxes');
      stateRows.forEach(addRow);
      addSubtotal('State subtotal', safeTotals.state.amount, safeTotals.state.pct);
    }
    if (federalRows.length) {
      addGroupHeader('Federal taxes');
      federalRows.forEach(addRow);
      addSubtotal('Federal subtotal', safeTotals.federal.amount, safeTotals.federal.pct);
    }
  }

  function buildCompareHref(code){
    const u = new URL(location.href);
    u.pathname = '/compare';
    u.searchParams.set('a', code);
    if (!u.searchParams.get('b')) u.searchParams.set('b','TX');
    return u.toString();
  }
  // Render stacked bar
  function renderStackedBar(segments, total){
    if (!barEl) return;
    barEl.innerHTML = '';
    const positive = segments.filter(s => s.value > 0);
    for (const s of positive) {
      const seg = document.createElement('section');
      seg.className = 'bar-seg';
      seg.style.width      = ((s.value / Math.max(1,total)) * 100) + '%';
      seg.style.background = s.color;
      seg.title = `${s.label}: ${fmt(s.value)} (${pctOf(s.value,total)})`;
      seg.setAttribute('aria-label', `${s.label}: ${fmt(s.value)} (${pctOf(s.value,total)})`);
      barEl.appendChild(seg);
    }
  }

  // Build inline SVG donut for the modal
  function buildPieHTML(title, segments){
    const data = segments.filter(s=>s.value>0);
    const total = data.reduce((a,s)=>a+s.value,0) || 1;
    const size=320, cx=size/2, cy=size/2, r=120, r0=72;

    let a0 = -Math.PI/2; // start at top
    const arcs = [];
    for (const s of data){
      const a1 = a0 + (s.value/total) * Math.PI*2;
      const large = (a1 - a0) > Math.PI ? 1 : 0;
      const x0 = cx + r*Math.cos(a0), y0 = cy + r*Math.sin(a0);
      const x1 = cx + r*Math.cos(a1), y1 = cy + r*Math.sin(a1);
      const x0i = cx + r0*Math.cos(a0), y0i = cy + r0*Math.sin(a0);
      const x1i = cx + r0*Math.cos(a1), y1i = cy + r0*Math.sin(a1);
      const d = [
        `M ${x0} ${y0}`,
        `A ${r} ${r} 0 ${large} 1 ${x1} ${y1}`,
        `L ${x1i} ${y1i}`,
        `A ${r0} ${r0} 0 ${large} 0 ${x0i} ${y0i}`,
        'Z'
      ].join(' ');
      arcs.push(`<path d="${d}" fill="${s.color}" />`);
      a0 = a1;
    }

    const legend = data.map(s => `
      <div class="legend__item">
        <span class="legend__swatch" style="background:${s.color}"></span>
        <span>${s.label} — <strong>${fmt(s.value)}</strong> (${pctOf(s.value,total)})</span>
      </div>
    `).join('');

    return `
      <div class="stack">
        <div class="big-number">${title}</div>
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" aria-label="Tax composition">
          ${arcs.join('')}
        </svg>
        <div class="legend">${legend}</div>
      </div>
    `;
  }

  async function computeDemoBreakdown(code) {
    const mySeq = ++_seq;

    if (!code) {
      currentState = '';
      setEmptyRow();
      applyToolbarState();
      return;
    }

    const inc  = Number(latestInputs.income) || 0;
    const hv   = Number(latestInputs.homeValue) || 0;

    const pack = await loadPack();
    if (!pack) { setLoadingRow(); return; }
    if (mySeq !== _seq) return; // stale compute, abort

    // ----- LOCAL CATEGORIES -----
    const rawLocalNumeric = [];
    if (scopeFlags.local) {
      let localSalesMissing = false;
      let localSalesValue = null;
      let localSalesTitle = undefined;
      if (pack && pack.sales) {
        const salesRow = findRow(pack.sales, code);
        if (!salesRow || isStub(salesRow, 'sales')) {
          localSalesMissing = true;
        } else if (typeof salesRow.avg_local_rate === 'number') {
          const spendingShare = Number(latestInputs.spendingShare) || 0.6;
          const rate = Math.max(0, salesRow.avg_local_rate);
          localSalesValue = Math.round(inc * spendingShare * rate);
          const annotations = [];
          if (latestInputs.locality && latestInputs.locality.countyName) {
            annotations.push(`County: ${latestInputs.locality.countyName}`);
          }
          if (latestInputs.locality && latestInputs.locality.fipsCounty) {
            annotations.push(`FIPS ${latestInputs.locality.fipsCounty}`);
          }
          if (rate > 0) {
            annotations.push(`Avg. local rate ${(rate * 100).toFixed(1)}%`);
          } else {
            annotations.push('Avg. local rate 0%');
          }
          localSalesTitle = annotations.join(' • ');
        } else {
          localSalesMissing = true;
        }
      } else {
        localSalesMissing = true;
      }
      rawLocalNumeric.push({
        key: 'local_sales',
        label: 'Local sales add-on',
        value: localSalesMissing ? null : localSalesValue,
        title: localSalesMissing ? 'Local rate data pending' : localSalesTitle
      });
    }

    // ----- STATE CATEGORIES -----
    let stIncome = 0, stIncomeMissing = false;
    if (pack && pack.income) {
      const row = findRow(pack.income, code);
      if (!row || isStub(row, 'income')) {
        stIncomeMissing = true;
      } else if (row.has_income_tax) {
        const std = row.standard_deduction || 0;
        const taxable = Math.max(0, inc - std);
        if (typeof row.flat === 'number') {
          stIncome = Math.round(taxable * row.flat);
        } else {
          const brackets = row.brackets || [];
          let prev = 0;
          for (const b of brackets) {
            const cap = (b.up_to == null) ? taxable : b.up_to;
            const slice = Math.max(0, Math.min(taxable, cap) - prev);
            stIncome += Math.round(slice * (b.rate || 0));
            prev = cap;
            if (prev >= taxable) break;
          }
        }
      } else {
        stIncomeMissing = true;
      }
    } else {
      stIncomeMissing = true;
    }

    let stSales = 0, stSalesMissing = false;
    if (pack && pack.sales) {
      const srow = findRow(pack.sales, code);
      if (!srow || isStub(srow, 'sales')) {
        stSalesMissing = true;
      } else {
        const rate = srow.combined_rate || 0;
        const spendingShare = Number(latestInputs.spendingShare) || 0.6;
        stSales = Math.round(inc * spendingShare * rate);
      }
    } else {
      stSalesMissing = true;
    }

    let stProperty = 0, stPropertyMissing = false;
    if (pack && pack.property) {
      const prow = findRow(pack.property, code);
      if (!prow || isStub(prow, 'property')) {
        stPropertyMissing = true;
      } else {
        const effRate = prow.effective_rate || 0;
        stProperty = Math.round(hv * effRate);
      }
    } else {
      stPropertyMissing = true;
    }

    // ----- FEDERAL (optional) -----
    let fedIncome = 0, fedPayroll = 0, fedLTCG = 0, payrollTitle = '';
    if (latestInputs.includeFederal) {
      const f = computeFederalTotals(pack, latestInputs);
      fedIncome  = f.federalIncome;
      fedPayroll = f.payroll;
      fedLTCG    = f.ltcgTax;

      const p = f.payrollAssumptions || {};
      if (p && p.ssBase != null) {
        payrollTitle = [
  `Social Security wage base $${Number(p.ssBase).toLocaleString()}`,
  `OASDI ${(p.ssRate*100).toFixed(1)}%`,
  `Medicare ${(p.mediRate*100).toFixed(2)}%`,
  `+ ${(p.addRate*100).toFixed(1)}% above $${Number(p.addThresh).toLocaleString()}`
].join(' · ');
      }
    }

    // Build rows + totals
    const rawStateNumeric = [
      { key:'income',   label: 'Income tax',   value: stIncomeMissing   ? null : stIncome },
      { key:'sales',    label: 'Sales tax',    value: stSalesMissing    ? null : stSales },
      { key:'property', label: 'Property tax', value: stPropertyMissing ? null : stProperty },
    ];
    const includeFederal = scopeFlags.federal && latestInputs.includeFederal;
    const rawFederalNumeric = [];
    if (includeFederal) {
      rawFederalNumeric.push({ key:'fed_income', label: 'Federal income',     value: fedIncome });
      rawFederalNumeric.push({ key:'payroll',    label: 'Payroll (employee)', value: fedPayroll, title: payrollTitle || undefined });
      if (fedLTCG > 0) rawFederalNumeric.push({ key:'ltcg', label:'LTCG', value: fedLTCG });
    }

    const localNumeric = scopeFlags.local ? rawLocalNumeric : [];
    const stateNumeric = scopeFlags.state ? rawStateNumeric : [];
    const federalNumeric = includeFederal ? rawFederalNumeric : [];

    const total = [...localNumeric, ...stateNumeric, ...federalNumeric].reduce((a, r) => a + (r.value ?? 0), 0);
    const localSum = localNumeric.reduce((a, r) => a + (r.value ?? 0), 0);
    const stateSum = stateNumeric.reduce((a, r) => a + (r.value ?? 0), 0);
    const fedSum   = federalNumeric.reduce((a, r) => a + (r.value ?? 0), 0);

    const toDisplay = (arr) => arr.map(r => ({
      key:    r.key,
      label:  r.label,
      amount: r.value == null ? '—' : fmt(r.value),
      pct:    r.value == null ? '—' : pctOf(r.value,total),
      title:  r.title
    }));
    const localDisplay   = toDisplay(localNumeric);
    const stateDisplay   = toDisplay(stateNumeric);
    const federalDisplay = toDisplay(federalNumeric);

    if (!localDisplay.length && !stateDisplay.length && !federalDisplay.length) {
      if (totEl) totEl.textContent = '--';
      if (effEl) effEl.textContent = '--';
      if (chipTotal) chipTotal.textContent = '--';
      if (chipEff) chipEff.textContent = '--';
      setPlaceholderRow('Enable a scope to view totals.');
      return;
    }

    // Normalize any placeholder/dash output to concrete zeros for MVP (no dashes)
    function normalizeDisplay(arr){
      return arr.map(r => ({
        ...r,
        amount: (typeof r.amount === 'string' && r.amount.indexOf('\uFFFD') >= 0) ? '$0' : r.amount,
        pct:    (typeof r.pct    === 'string' && r.pct.indexOf('\uFFFD')    >= 0) ? '0.0%' : r.pct,
      }));
    }
    const localDisplayNorm   = normalizeDisplay(localDisplay);
    const stateDisplayNorm   = normalizeDisplay(stateDisplay);
    const federalDisplayNorm = normalizeDisplay(federalDisplay);

    // Update chips + table
    if (totEl) totEl.textContent = fmt(total);
    const effRateStr = ((total / Math.max(1, inc)) * 100).toFixed(1) + '%';
    if (effEl) effEl.textContent = effRateStr;
    if (chipTotal) chipTotal.textContent = totEl ? totEl.textContent : fmt(total);
    if (chipEff)   chipEff.textContent   = effEl ? effEl.textContent : effRateStr;

    renderBreakdownRows(
      localDisplayNorm,
      stateDisplayNorm,
      federalDisplayNorm,
      {
        local: { amount: localDisplayNorm.length ? fmt(localSum) : '--', pct: localDisplayNorm.length ? pctOf(localSum,total) : '--' },
        state: { amount: stateDisplayNorm.length ? fmt(stateSum) : '--', pct: stateDisplayNorm.length ? pctOf(stateSum,total) : '--' },
        federal: { amount: federalDisplayNorm.length ? fmt(fedSum) : '--', pct: federalDisplayNorm.length ? pctOf(fedSum,total) : '--' }
      }
    );

    // Build stacked-bar segments (local + state + federal) with colors
    const segments = [...localNumeric, ...stateNumeric, ...federalNumeric]
      .filter(r => (r.value ?? 0) > 0)
      .map(r => ({ key:r.key, label:r.label, value:r.value, color: colorForKey(r.key) }));
    _lastSegments = segments; // store for "Open chart"
    renderStackedBar(segments, total);

    // ---- Emit a structured snapshot so Compare can render side-by-side ----
    const snapshot = {
      slot,
      state: code,
      inputs: {
        filingStatus: latestInputs.filingStatus,
        income: inc,
        includeFederal: !!latestInputs.includeFederal,
        ltcg: latestInputs.ltcg,
        locality: latestInputs.locality || null
      },
      totals: {
        localSubtotal: localSum,
        stateSubtotal: stateSum,
        federalSubtotal: fedSum,
        total,
        effectiveRate: total / Math.max(1, inc)
      },
      rows: {
        local: localNumeric,
        state: stateNumeric,
        federal: federalNumeric
      },
      scopes: { ...scopeFlags }
    };
    root.dispatchEvent(new CustomEvent('t1:breakdown-computed', { detail: snapshot, bubbles: true }));
  }

  function updateState(val) {
    const code = normalizeStateCode(val);

    if (!code) {
      currentState = '';
      root.setAttribute('data-state', '');
      setEmptyRow();
      applyToolbarState();
      return;
    }

    currentState = code;
    root.setAttribute('data-state', code);

    // Read latest inputs from the form so the next compute reflects the current UI
    try {
      const form = document.querySelector('form[aria-label="Tax inputs"]');
      if (form) {
        const get = id => form.querySelector('#' + id);
        const incEl  = get('inc');
        const hvEl   = get('hv');
        const hoEl   = get('ho');
        const fsEl   = get('fs');
        const ssEl   = get('ss');
        const tsEl   = get('ts');
        const fedEl  = get('fed');
        const ltcgEl = get('ltcg');
        const parse = (v) => Number(String(v||'').replace(/[^0-9.-]/g,'')) || 0;

        latestInputs.income         = incEl  ? parse(incEl.value)  : latestInputs.income;
        latestInputs.homeValue      = hvEl   ? parse(hvEl.value)   : latestInputs.homeValue;
        latestInputs.homeowner      = hoEl   ? (hoEl.value === '1') : latestInputs.homeowner;
        latestInputs.filingStatus   = fsEl   ? (fsEl.value || 'single') : latestInputs.filingStatus;
        latestInputs.spendingShare  = ssEl   ? (+ssEl.value)           : latestInputs.spendingShare;
        latestInputs.taxableShare   = tsEl   ? (+tsEl.value)           : latestInputs.taxableShare;
        latestInputs.includeFederal = fedEl  ? (fedEl.value === '1')   : latestInputs.includeFederal;
        latestInputs.ltcg           = ltcgEl ? parse(ltcgEl.value)     : latestInputs.ltcg;
      }
    } catch {}

    setLoadingRow();
    applyToolbarState();

    requestAnimationFrame(() => computeDemoBreakdown(code));
  }

  // Map selects a new state
  window.addEventListener('t1:state', (e) => {
    if (slot !== 'solo') return;
    updateState(e.detail || null);
  });

  // Inputs changed — recompute current state (next frame)
  window.addEventListener('t1:inputs', (e) => {
    const d = e.detail || {};
    latestInputs.filingStatus   = d.filingStatus   ?? latestInputs.filingStatus;
    latestInputs.income         = d.income         ?? latestInputs.income;
    latestInputs.homeValue      = d.homeValue      ?? latestInputs.homeValue;
    latestInputs.homeowner      = (typeof d.homeowner === 'boolean') ? d.homeowner : latestInputs.homeowner;
    latestInputs.miles          = d.miles          ?? latestInputs.miles;
    latestInputs.mpg            = d.mpg            ?? latestInputs.mpg;
    latestInputs.spendingShare  = d.spendingShare  ?? latestInputs.spendingShare;
    latestInputs.taxableShare   = d.taxableShare   ?? latestInputs.taxableShare;
    latestInputs.includeFederal = (typeof d.includeFederal === 'boolean') ? d.includeFederal : latestInputs.includeFederal;
    latestInputs.ltcg           = d.ltcg           ?? latestInputs.ltcg;
    if (d.scopes) {
      latestInputs.scopes = { ...latestInputs.scopes, ...d.scopes };
      scopeFlags.local = !!latestInputs.scopes.local;
      scopeFlags.state = !!latestInputs.scopes.state;
      scopeFlags.federal = !!latestInputs.scopes.federal;
    }
    if (d.locality) {
      latestInputs.locality = { ...latestInputs.locality, ...d.locality };
    }

    if (!currentState) {
      setEmptyRow();
      applyToolbarState();
      return;
    }
    requestAnimationFrame(() => computeDemoBreakdown(currentState));
  });

  // Fallback: recompute on any input/change events from the inputs form to
  // guarantee instant updates even if the custom event path is interrupted.
  (function ensureInstantRecompute() {
    const form = document.querySelector('form[aria-label="Tax inputs"]');
    if (!form) return;
    const capture = () => {
      try {
        const get = (id) => form.querySelector('#' + id);
        const parse = (v) => Number(String(v||'').replace(/[^0-9.-]/g,'')) || 0;
        latestInputs.income         = get('inc')  ? parse(get('inc').value)  : latestInputs.income;
        latestInputs.homeValue      = get('hv')   ? parse(get('hv').value)   : latestInputs.homeValue;
        latestInputs.homeowner      = get('ho')   ? (get('ho').value === '1') : latestInputs.homeowner;
        latestInputs.filingStatus   = get('fs')   ? (get('fs').value || 'single') : latestInputs.filingStatus;
        latestInputs.spendingShare  = get('ss')   ? (+get('ss').value)           : latestInputs.spendingShare;
        latestInputs.taxableShare   = get('ts')   ? (+get('ts').value)           : latestInputs.taxableShare;
        latestInputs.includeFederal = get('fed')  ? (get('fed').value === '1')   : latestInputs.includeFederal;
        latestInputs.ltcg           = get('ltcg') ? parse(get('ltcg').value)     : latestInputs.ltcg;
      } catch {}
      if (!currentState) {
        setEmptyRow();
        applyToolbarState();
        return;
      }
      requestAnimationFrame(() => computeDemoBreakdown(currentState));
    };
    form.addEventListener('input', capture, { passive: true });
    form.addEventListener('change', capture);
  })();

  // Compare slots support
  window.addEventListener('t1:state-left',  (e) => { if (slot === 'left')  updateState(e.detail || null); });
  window.addEventListener('t1:state-right', (e) => { if (slot === 'right') updateState(e.detail || null); });

  window.addEventListener('t1:scope-changed', (event) => {
    if (slot !== 'solo') return;
    const detail = event.detail || {};
    if (typeof detail.local === 'boolean') scopeFlags.local = detail.local;
    if (typeof detail.state === 'boolean') scopeFlags.state = detail.state;
    if (typeof detail.federal === 'boolean') scopeFlags.federal = detail.federal;
    if (!currentState) {
      if (!scopeFlags.local && !scopeFlags.state && !scopeFlags.federal) {
        if (chipTotal) chipTotal.textContent = '--';
        if (chipEff) chipEff.textContent = '--';
        setPlaceholderRow('Enable a scope to view totals.');
      }
      return;
    }
    requestAnimationFrame(() => computeDemoBreakdown(currentState));
  });

  let copyToastTimer = 0;
  function showCopyToast(message, tone = 'info') {
    if (typeof document === 'undefined') return;
    let toast = document.getElementById('bd-copy-toast');
    if (!toast) {
      toast = document.createElement('div');
      toast.id = 'bd-copy-toast';
      toast.setAttribute('role', 'status');
      toast.setAttribute('aria-live', 'polite');
      toast.style.position = 'fixed';
      toast.style.bottom = '1.5rem';
      toast.style.left = '50%';
      toast.style.transform = 'translateX(-50%)';
      toast.style.padding = '0.5rem 0.75rem';
      toast.style.borderRadius = '999px';
      toast.style.fontSize = '0.85rem';
      toast.style.zIndex = '4000';
      toast.style.pointerEvents = 'none';
      toast.style.color = '#fff';
      toast.style.boxShadow = '0 12px 28px rgba(0,0,0,0.22)';
      document.body.appendChild(toast);
    }
    toast.textContent = message;
    toast.style.background = tone === 'error' ? 'rgba(176, 46, 59, 0.92)' : 'rgba(26, 30, 40, 0.92)';
    toast.style.opacity = '1';
    toast.style.transition = 'opacity 180ms ease';
    if (copyToastTimer) window.clearTimeout(copyToastTimer);
    copyToastTimer = window.setTimeout(() => {
      if (!toast) return;
      toast.style.opacity = '0';
      window.setTimeout(() => {
        if (toast && toast.parentElement) toast.parentElement.removeChild(toast);
      }, 220);
      copyToastTimer = 0;
    }, tone === 'error' ? 2000 : 1500);
  }

  // Copy link (local toolbar)
  copyBtn?.addEventListener('click', async () => {
    let shareURL = location.href;
    try {
      const share = typeof window !== 'undefined' ? window.__T1_SHARE__ : null;
      if (share && typeof share.encode === 'function') {
        const encoded = share.encode();
        if (encoded && typeof encoded.toString === 'function') {
          shareURL = encoded.toString();
        }
      }
    } catch (err) {
      try { console.warn('Breakdown: share encode failed', err); } catch (_e) {}
    }
    try {
      await navigator.clipboard.writeText(shareURL);
      copyBtn.textContent = 'Copied!';
      setTimeout(() => { copyBtn.textContent = 'Copy link'; }, 1200);
      showCopyToast('Link copied');
    } catch (err) {
      try { console.warn('Breakdown: clipboard write failed', err); } catch (_e) {}
      showCopyToast('Copy failed', 'error');
    }
  });

  // Open chart (pie modal)
  pieBtn?.addEventListener('click', () => {
    if (!currentState || !_lastSegments.length) return;
    const html = buildPieHTML(`${currentState} tax mix`, _lastSegments);
    window.dispatchEvent(new CustomEvent('t1:modal-open', { detail: { title: 'Tax composition', html } }));
  });

  // Initialize from URL (?fips=06 or ?state=CA), else use data-state
  try {
    const url  = new URL(location.href);
    const fips = url.searchParams.get('fips');
    const st   = url.searchParams.get('state');
    updateState(st || fips || initialCodeAttr || null);
  } catch {
    updateState(initialCodeAttr || null);
  }
})();
</script>



