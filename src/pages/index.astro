---
import '../styles/tokens.css';
import '../styles/utilities.css';
import Map from '../components/Map.astro';
import Inputs from '../components/Inputs.astro';
import Breakdown from '../components/Breakdown.astro';
import Assumptions from '../components/Assumptions.astro';
import ContextCards from '../components/ContextCards.astro';
import pack from '../../data/packs/2025.1.0.json';
import Modal from '../components/Modal.astro';
import TaxDeadlinesBanner from '../components/TaxDeadlinesBanner.astro';
import permalinkControllerSrc from '../scripts/permalink-controller.js?url';

const packSerialized = JSON.stringify(pack).replace(/</g, '\\u003c');
const packInline = `JSON.parse(decodeURIComponent('${encodeURIComponent(packSerialized)}'))`;
const seedPackScript = `(function(){try{const pack=${packInline};if(!window.__t1_pack)window.__t1_pack=pack;if(!window.__T1_PACK__)window.__T1_PACK__=pack;}catch(err){console.warn('seedPackScript failed',err);}})();`;
const faqJson = JSON.stringify({
  '@context': 'https://schema.org',
  '@type': 'FAQPage',
  mainEntity: [
    {
      '@type': 'Question',
      name: 'What taxes are included?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'State income, sales, property, fuel, and optional excise. Federal income, payroll, and LTCG are optional toggles.',
      },
    },
    {
      '@type': 'Question',
      name: 'Where does the data come from?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'Official DoR/DOT/ACS/BEA/BLS/IRS sources compiled into a versioned pack with a provenance registry.',
      },
    },
  ],
}).replace(/</g, '\\u003c');
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; connect-src 'self'; font-src 'self' data:;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>T1 - State + Federal Tax Burden Map</title>
    <meta name="description" content="Interactive state tax burden estimator with optional federal layer." />
    <meta property="og:title" content="T1 - State + Federal Tax Burden Map" />
    <meta property="og:description" content="Interactive state & local tax burden estimator with optional federal layer." />
    <script type="application/ld+json" set:html={faqJson}></script>
  </head>
  <body>
    <script set:html={seedPackScript}></script>
    <script type="module" src={permalinkControllerSrc}></script>
    <main class="container stack">
      <header class="page-header stack">
        <div class="page-header__title">
          <h1 class="heading--tight">T1 - State + Federal Tax Burden Map</h1>
          <span class="chip chip--meta" aria-label="Last updated">
            Last updated | Pack {pack.registry.pack_version} | {pack.registry.built_at}
          </span>
        </div>
        <TaxDeadlinesBanner />
      </header>

      <div class="grid grid--sidebar">
        <section class="panel stack">
          <Inputs id="inputs" />
          <Assumptions pack={pack} />
        </section>

        <section class="stack">
          <Map />
          <Breakdown initialState={null} pack={pack} />
          <ContextCards pack={pack} initialState={null} />
        </section>
      </div>
    </main>
    <Modal />
    <script type="module">
      try {
        const t = document.querySelector('h1.heading--tight');
        if (t) t.textContent = 'T1 - State + Federal Tax Burden Map';
        const og = document.querySelector('meta[property="og:title"]');
        if (og) og.setAttribute('content','T1 - State + Federal Tax Burden Map');
        document.title = 'T1 - State + Federal Tax Burden Map';
      } catch {}
    </script>
    <!-- Inject the current data pack for all client scripts -->
<script id="t1-pack" type="application/json" set:html={packSerialized}></script>
<script type="module">
  try {
    if (!window.__T1_PACK__ && window.__t1_pack) {
      window.__T1_PACK__ = window.__t1_pack;
    }
  } catch (e) {
    console.warn('t1-pack inject failed', e);
  }
</script>
    <script type="module">
      // Minimal in-page controller stub to surface geo/local scope for debugging.
      try {
        const DEFAULT_CATEGORIES = [
          { id: 'local-income', enabled: true },
          { id: 'local-sales', enabled: true },
          { id: 'lodging', enabled: false },
          { id: 'car-rental', enabled: false },
          { id: 'prepared-foods', enabled: false },
          { id: 'parking', enabled: false },
        ];

        const toToggleMap = (cats = DEFAULT_CATEGORIES) => {
          const map = {};
          cats.forEach((c) => {
            if (!c || !c.id) return;
            map[c.id] = !!c.enabled;
          });
          return map;
        };

        const encodeMask = (state = {}) => {
          let mask = 0;
          DEFAULT_CATEGORIES.forEach((cat, idx) => {
            if (state[cat.id]) mask |= 1 << idx;
          });
          return mask;
        };

        const cloneGeoSelection = (src = geoSelection) => ({
          layer: src && src.layer === 'county' ? 'county' : 'state',
          stateFips: src && src.stateFips ? src.stateFips : null,
          countyFips: src && src.countyFips ? src.countyFips : null,
        });

        const cloneLocalScope = (src = localScope) => ({
          enabled: !!(src && src.enabled),
          zip: src && src.zip ? src.zip : null,
          city: src && src.city ? src.city : null,
          stateFips: src && src.stateFips ? src.stateFips : null,
          countyFips: src && src.countyFips ? src.countyFips : null,
          categories: { ...(src && src.categories ? src.categories : {}) },
          toggles: src && src.toggles != null ? src.toggles : 0,
        });

        const existingCtrl = window.__T1_CONTROLLER__ || null;
        const existingHasAPI = existingCtrl && typeof existingCtrl.getGeoSelection === 'function' && typeof existingCtrl.getLocalScope === 'function';
        if (existingHasAPI) {
          console.log('[index stub] controller already present; stub disabled');
          return;
        }

        const defaultCategories = toToggleMap(DEFAULT_CATEGORIES);
        let geoSelection = existingCtrl && existingCtrl.geoSelection ? cloneGeoSelection(existingCtrl.geoSelection) : { layer: 'state', stateFips: null, countyFips: null };
        let localScope = existingCtrl && existingCtrl.localScope ? cloneLocalScope(existingCtrl.localScope) : {
          enabled: true,
          zip: null,
          city: null,
          stateFips: null,
          countyFips: null,
          categories: { ...defaultCategories },
          toggles: encodeMask(defaultCategories),
        };

        if (existingCtrl && !existingHasAPI) {
          // Patch existing controller with missing API surface while preserving any existing state references.
          existingCtrl.getGeoSelection = () => cloneGeoSelection(existingCtrl.geoSelection || geoSelection);
          existingCtrl.getLocalScope = () => cloneLocalScope(existingCtrl.localScope || localScope);
          if (typeof existingCtrl.setGeoSelection !== 'function') existingCtrl.setGeoSelection = (patch = {}) => {
            geoSelection = { ...geoSelection, ...patch, layer: patch.layer === 'county' ? 'county' : 'state' };
            if (patch.stateFips !== undefined) geoSelection.stateFips = patch.stateFips ? String(patch.stateFips).padStart(2, '0') : null;
            if (patch.countyFips !== undefined) geoSelection.countyFips = patch.countyFips ? String(patch.countyFips) : null;
            if (patch.stateFips !== undefined) geoSelection.countyFips = null;
            existingCtrl.geoSelection = cloneGeoSelection(geoSelection);
            return existingCtrl.getGeoSelection();
          };
          if (typeof existingCtrl.setLocalScope !== 'function') existingCtrl.setLocalScope = (patch = {}) => {
            localScope = { ...localScope, ...patch };
            if (patch.stateFips !== undefined) {
              localScope.stateFips = patch.stateFips ? String(patch.stateFips).padStart(2, '0') : null;
              localScope.countyFips = null;
            }
            existingCtrl.localScope = cloneLocalScope(localScope);
            return existingCtrl.getLocalScope();
          };
          window.__T1_CONTROLLER__ = existingCtrl;
          console.log('[index stub] patched existing controller with geo/local API');
          return;
        }


        const setGeoSelection = (patch = {}) => {
          const nextLayer = patch.layer === 'county' ? 'county' : 'state';
          let nextState = patch.stateFips ?? geoSelection.stateFips ?? null;
          nextState = nextState != null ? String(nextState).padStart(2, '0') : null;
          let nextCounty = patch.countyFips !== undefined ? patch.countyFips : geoSelection.countyFips;
          nextCounty = nextCounty != null ? String(nextCounty) : nextCounty;
          const stateChanged = nextState !== geoSelection.stateFips;
          if (stateChanged) nextCounty = null;
          geoSelection = { layer: nextLayer, stateFips: nextState, countyFips: nextCounty };
          localScope = { ...localScope, stateFips: geoSelection.stateFips, countyFips: geoSelection.countyFips };
          const snapshot = cloneGeoSelection();
          try {
            window.dispatchEvent(new CustomEvent('t1:geo-selection', { detail: { ...snapshot, geoSelection: { ...snapshot } } }));
            window.dispatchEvent(new CustomEvent('t1:state', { detail: { ...snapshot, fips: snapshot.stateFips, geoSelection: { ...snapshot } } }));
          } catch (err) {
            console.warn('[index stub] emit failed', err);
          }
          return snapshot;
        };

        const setLocalScope = (patch = {}) => {
          const next = cloneLocalScope();
          if (typeof patch.enabled === 'boolean') next.enabled = patch.enabled;
          if (patch.zip !== undefined) next.zip = patch.zip || null;
          if (patch.city !== undefined) next.city = patch.city || null;
          if (patch.stateFips !== undefined) {
            next.stateFips = patch.stateFips ? String(patch.stateFips).padStart(2, '0') : null;
            next.countyFips = null;
          }
          if (patch.countyFips !== undefined) next.countyFips = patch.countyFips ? String(patch.countyFips) : null;
          if (patch.categories && typeof patch.categories === 'object') {
            next.categories = { ...next.categories, ...patch.categories };
          }
          if (patch.toggles != null) {
            next.toggles = Number(patch.toggles) || 0;
          } else {
            next.toggles = encodeMask(next.categories);
          }
          localScope = next;
          if (patch.stateFips !== undefined && geoSelection.stateFips !== next.stateFips) {
            setGeoSelection({ stateFips: next.stateFips, countyFips: null, layer: 'state' });
          }
          return cloneLocalScope();
        };

        const getGeoSelection = () => cloneGeoSelection();
        const getLocalScope = () => cloneLocalScope();

        const controller = {
          debug: 'stub-from-index',
          getGeoSelection,
          setGeoSelection,
          getLocalScope,
          setLocalScope,
        };

        window.__T1_CONTROLLER__ = controller;
        console.log('[index stub] __T1_CONTROLLER__ attached', controller);

        window.addEventListener('t1:state', (event) => {
          const detail = event.detail || {};
          const fips = detail.stateFips || detail.fips || null;
          setGeoSelection({ stateFips: fips, layer: 'state', countyFips: null });
        });
      } catch (err) {
        console.warn('[index stub] failed to attach controller stub', err);
      }
    </script>
    <script type="module">
      // Final guard: ensure window.__T1_CONTROLLER__ exists with geo/local APIs
      (() => {
        const ensureString = (v) => (v == null ? null : String(v));
        const normState = (v) => {
          const s = ensureString(v);
          return s && s.trim() ? s.padStart(2, '0').slice(0, 2) : null;
        };
        const cloneGeo = (src) => ({
          layer: src && src.layer === 'county' ? 'county' : 'state',
          stateFips: src && src.stateFips ? src.stateFips : null,
          countyFips: src && src.countyFips ? src.countyFips : null,
        });
        const cloneLocal = (src) => ({
          enabled: !!(src && src.enabled),
          zip: src && src.zip ? src.zip : null,
          city: src && src.city ? src.city : null,
          stateFips: src && src.stateFips ? src.stateFips : null,
          countyFips: src && src.countyFips ? src.countyFips : null,
          categories: { ...(src && src.categories ? src.categories : {}) },
          toggles: src && src.toggles != null ? src.toggles : 0,
        });

        const hasAPI = (ctrl) =>
          ctrl &&
          typeof ctrl.getGeoSelection === 'function' &&
          typeof ctrl.getLocalScope === 'function' &&
          typeof ctrl.setGeoSelection === 'function' &&
          typeof ctrl.setLocalScope === 'function';

        const installFallback = () => {
          const DEFAULT_CATS = {
            'local-income': true,
            'local-sales': true,
            lodging: false,
            'car-rental': false,
            'prepared-foods': false,
            parking: false,
          };
          const encodeMask = (state = {}) =>
            Object.keys(DEFAULT_CATS).reduce((mask, key, idx) => (state[key] ? mask | (1 << idx) : mask), 0);

          let geo = { layer: 'state', stateFips: null, countyFips: null };
          let local = {
            enabled: true,
            zip: null,
            city: null,
            stateFips: null,
            countyFips: null,
            categories: { ...DEFAULT_CATS },
            toggles: encodeMask(DEFAULT_CATS),
          };

          const setGeoSelection = (patch = {}) => {
            const nextLayer = patch.layer === 'county' ? 'county' : 'state';
            const nextState = patch.stateFips !== undefined ? normState(patch.stateFips) : geo.stateFips;
            let nextCounty =
              patch.countyFips !== undefined ? ensureString(patch.countyFips) : geo.countyFips;
            if (nextState !== geo.stateFips) nextCounty = null;
            geo = { layer: nextLayer, stateFips: nextState, countyFips: nextCounty };
            local = { ...local, stateFips: geo.stateFips, countyFips: geo.countyFips };
            return cloneGeo(geo);
          };

          const setLocalScope = (patch = {}) => {
            const next = cloneLocal(local);
            if (typeof patch.enabled === 'boolean') next.enabled = patch.enabled;
            if (patch.zip !== undefined) next.zip = patch.zip || null;
            if (patch.city !== undefined) next.city = patch.city || null;
            if (patch.stateFips !== undefined) {
              next.stateFips = normState(patch.stateFips);
              next.countyFips = null;
            }
            if (patch.countyFips !== undefined) next.countyFips = ensureString(patch.countyFips);
            if (patch.categories && typeof patch.categories === 'object') {
              next.categories = { ...next.categories, ...patch.categories };
            }
            if (patch.toggles != null) {
              next.toggles = Number(patch.toggles) || 0;
            } else {
              next.toggles = encodeMask(next.categories);
            }
            local = next;
            return cloneLocal(local);
          };

          const ctrl = {
            getGeoSelection: () => cloneGeo(geo),
            setGeoSelection,
            getLocalScope: () => cloneLocal(local),
            setLocalScope,
            geoSelection: cloneGeo(geo),
            localScope: cloneLocal(local),
          };
          window.__T1_CONTROLLER__ = ctrl;
          window.addEventListener('t1:state', (e) => {
            const detail = e.detail || {};
            const fips = detail.stateFips || detail.fips || null;
            setGeoSelection({ stateFips: fips, layer: 'state', countyFips: null });
          });
          return ctrl;
        };

        const maybePatch = () => {
          const existing = window.__T1_CONTROLLER__ || null;
          if (hasAPI(existing)) return existing;
          if (existing && typeof existing === 'object') {
            if (typeof existing.getGeoSelection !== 'function') existing.getGeoSelection = () => cloneGeo(existing.geoSelection || {});
            if (typeof existing.getLocalScope !== 'function') existing.getLocalScope = () => cloneLocal(existing.localScope || {});
            if (typeof existing.setGeoSelection !== 'function') existing.setGeoSelection = (patch = {}) => {
              const next = existing.geoSelection || {};
              existing.geoSelection = cloneGeo({
                ...next,
                layer: patch.layer === 'county' ? 'county' : 'state',
                stateFips: patch.stateFips !== undefined ? normState(patch.stateFips) : next.stateFips || null,
                countyFips:
                  patch.countyFips !== undefined
                    ? ensureString(patch.countyFips)
                    : next.stateFips !== (patch.stateFips !== undefined ? normState(patch.stateFips) : next.stateFips)
                      ? null
                      : next.countyFips || null,
              });
              return existing.getGeoSelection();
            };
            if (typeof existing.setLocalScope !== 'function') existing.setLocalScope = (patch = {}) => {
              const next = cloneLocal(existing.localScope || {});
              if (typeof patch.enabled === 'boolean') next.enabled = patch.enabled;
              if (patch.zip !== undefined) next.zip = patch.zip || null;
              if (patch.city !== undefined) next.city = patch.city || null;
              if (patch.stateFips !== undefined) {
                next.stateFips = normState(patch.stateFips);
                next.countyFips = null;
              }
              if (patch.countyFips !== undefined) next.countyFips = ensureString(patch.countyFips);
              if (patch.categories && typeof patch.categories === 'object') {
                next.categories = { ...next.categories, ...patch.categories };
              }
              existing.localScope = cloneLocal(next);
              return existing.getLocalScope();
            };
            return (window.__T1_CONTROLLER__ = existing);
          }
          return installFallback();
        };

        maybePatch();
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', maybePatch, { once: true });
        }
      })();
    </script>
  </body>
</html>
